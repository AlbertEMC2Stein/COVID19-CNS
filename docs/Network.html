<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.Network API documentation</title>
<meta name="description" content="TODO Docstring Network" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Network</code></h1>
</header>
<section id="section-intro">
<p>TODO Docstring Network</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
TODO Docstring Network
&#34;&#34;&#34;

__all__ = [&#39;Member&#39;, &#39;Household&#39;, &#39;Population&#39;, &#39;Group&#39;]

import textwrap
import numpy as np
import csv
import json
from os.path import sep
from src.Utils import ProgressBar, Counter


################################################################################################
################################################################################################
################################################################################################


class Member:
    def __init__(self, properties: dict):
        &#34;&#34;&#34;
        TODO Docstring Member __init__
        &#34;&#34;&#34;

        def check(_properties: dict):
            must_haves = [&#34;id&#34;, &#34;household&#34;]

            for property in must_haves:
                if property not in _properties.keys():
                    raise KeyError(&#34;Properties have to contain &#39;&#34; + property + &#34;&#39;.&#34;)

            return _properties

        self.properties = check(properties)
        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self.dead = False
        self.immune = False
        self.quarantined = False
        self.recent_contacts = []
        self._susceptible_in = -1
        self._infectious_in = -1
        self._recovers_in = -1
        self._immune_in = -1
        self._released_in = -1
        self._last_tested = -1

    def __str__(self):
        return &#34;\n&#34;.join([&#34;%s = %s&#34; % (attr, val) for attr, val in self.__dict__.items()])

    def infect(self, infectant: &#39;Member&#39;, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        TODO Docstring Member infect
        &#34;&#34;&#34;

        n_incubation = disease_parameters[&#34;incubation_period&#34;]
        n_infection = disease_parameters[&#34;infection_period&#34;]
        shared_household = self.properties[&#34;household&#34;] == infectant.properties[&#34;household&#34;]

        if (self.immune and not self.vaccinated) or self.infected or \
                self.dead or (self.quarantined and not shared_household):
            return False

        if self.vaccinated and self._immune_in &lt;= 0:
            p_failure = disease_parameters[&#34;vaccine_failure_probability_heuristic&#34;](self, timestamp)
            if np.random.uniform() &gt; p_failure:
                return False

        infection_data = [(infectant.properties[&#34;id&#34;],
                           shared_household,
                           timestamp,
                           timestamp + n_incubation,
                           timestamp + n_incubation + n_infection)]

        if &#34;infections&#34; not in self.properties.keys():
            self.properties[&#34;infections&#34;] = infection_data

        else:
            self.properties[&#34;infections&#34;] += infection_data

        self.infected = True
        self._infectious_in = n_incubation
        self._recovers_in = n_infection
        self._susceptible_in = disease_parameters[&#34;immunity_period&#34;]

        return True

    def vaccinate(self, timestamp: int, vaccine_parameters: dict):
        &#34;&#34;&#34;
        TODO Docstring Member vaccinate
        &#34;&#34;&#34;

        vaccine_unavailable = self.infected or self.dead or self.quarantined or \
                              &#34;vaccinations&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;vaccinations&#34;][-1][1] + vaccine_parameters[&#34;t_wait_vac&#34;] or \
                              &#34;infections&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;infections&#34;][-1][4] + vaccine_parameters[&#34;t_wait_rec&#34;]

        if not vaccine_unavailable:
            vaccination_data = [(timestamp,
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;],
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;] + vaccine_parameters[&#34;t_immunity&#34;])]

            if &#34;vaccinations&#34; in self.properties.keys():
                self.properties[&#34;vaccinations&#34;] += vaccination_data

            else:
                self.properties[&#34;vaccinations&#34;] = vaccination_data

            if self.immune:
                self._immune_in = 0
                self._susceptible_in = max(vaccine_parameters[&#34;t_immunity&#34;], self._susceptible_in)

            else:
                self._immune_in = vaccine_parameters[&#34;t_vac_effect&#34;]
                self._susceptible_in = vaccine_parameters[&#34;t_immunity&#34;]

            return True

        return False

    def test(self, timestamp: int):
        &#34;&#34;&#34;
        TODO Docstring Member test
        &#34;&#34;&#34;

        result = self.infected * (np.random.uniform() &lt; 0.99)

        if &#34;tests&#34; not in self.properties.keys():
            self.properties[&#34;tests&#34;] = [0, 0]

        self.properties[&#34;tests&#34;][result] += 1
        self._last_tested = timestamp

        return result

    def quarantine(self, days: int):
        &#34;&#34;&#34;
        TODO Docstring Member quarantine
        &#34;&#34;&#34;

        self.quarantined = True
        self._released_in = days

    def add_to_contacts(self, other):
        &#34;&#34;&#34;
        TODO Docstring Member add_to_contacts
        &#34;&#34;&#34;

        if len(self.recent_contacts) &lt; 5:
            self.recent_contacts += [other]

        else:
            self.recent_contacts = self.recent_contacts[1:] + [other]

    def make_immune(self, immunity_duration: int):
        &#34;&#34;&#34;
        TODO Docstring Member make_immune
        &#34;&#34;&#34;

        if self.infected:
            raise RuntimeError
            self.infected = False
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return True

        else:
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return False

    def make_dead(self, timestamp: int):
        &#34;&#34;&#34;
        TODO Docstring Member make_dead
        &#34;&#34;&#34;

        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self._susceptible_in = -1
        self._recovers_in = -1
        self._infectious_in = -1
        self._immune_in = -1

        self.dead = True
        self.properties[&#34;Death&#34;] = timestamp

    def make_tick(self, option: str, timestamp: int = None):
        &#34;&#34;&#34;
        TODO Docstring Member make_tick
        &#34;&#34;&#34;

        if option == &#34;infectious&#34;:
            if self._infectious_in &gt; 0:
                self._infectious_in -= 1

            return self._infectious_in &lt;= 0

        elif option == &#34;immunity&#34;:
            if self._immune_in &lt;= 0:
                self._susceptible_in -= 1
                if self._susceptible_in == 0:
                    self._susceptible_in = -1
                    self.immune = False
                    return True

            return False

        elif option == &#34;vaccine&#34;:
            self._immune_in -= 1
            if self._immune_in == 0:
                self.immune = True

        elif option == &#34;recover&#34;:
            self._recovers_in -= 1
            if self._recovers_in == 0:
                self._recovers_in = -1
                self.infected = False
                self.immune = True
                return True

            return False

        elif option == &#34;quarantine&#34;:
            self._released_in -= 1

            if &#34;days_in_quarantine&#34; not in self.properties.keys():
                self.properties[&#34;days_in_quarantine&#34;] = 0

            self.properties[&#34;days_in_quarantine&#34;] += 1

            if self._released_in == 0:
                if self.test(timestamp):
                    self._released_in += 5
                else:
                    self._released_in = -1
                    self.quarantined = False
                    return True

            return False

        else:
            raise ValueError(&#34;option not supported&#34;)

    def copy(self):
        &#34;&#34;&#34;
        TODO Docstring Member copy
        &#34;&#34;&#34;

        m = Member(self.properties.copy())
        m.infected = self.infected
        m.recovered = self.recovered
        m.vaccinated = self.vaccinated
        m.dead = self.dead
        m._susceptible_in = self._susceptible_in
        m._recovers_in = self._recovers_in
        m._infectious_in = self._infectious_in
        m._immune_in = self._immune_in

        return m


################################################################################################
################################################################################################
################################################################################################


class Group:
    def __init__(self, name: str):
        &#34;&#34;&#34;
        TODO Docstring Group __init__
        &#34;&#34;&#34;

        self.name = name
        self.members = np.array([])
        self.counter = Counter(0)

    def __str__(self):
        result = self.__class__.__name__ + &#34;: &#34; + self.name + &#34;\nMembers: &#34;
        for member in self:
            result += str(member) + &#34;\n\t\t &#34;

        return result[:-1]

    def __iter__(self):
        return iter(self.members)

    def add_member(self, member: Member):
        &#34;&#34;&#34;
        TODO Docstring Group add_member
        &#34;&#34;&#34;

        self.members = np.append(self.members, member)
        self.counter.increment()

    def remove_member(self, member: Member):
        &#34;&#34;&#34;
        TODO Docstring Group remove_member
        &#34;&#34;&#34;

        old_size = self.members.size
        self.members = self.members[self.members != member]
        self.counter.decrement(old_size - self.members.size)

    def spread_disease(self, infectant: Member, n: int, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        TODO Docstring Group spread_disease
        &#34;&#34;&#34;

        result = []
        for other in np.random.choice(self.members, n):
            if infectant.properties[&#34;id&#34;] == other.properties[&#34;id&#34;]:
                continue

            infectant.add_to_contacts(other)

            if np.random.uniform() &lt; disease_parameters[&#34;infection_probability_heuristic&#34;](other.properties):
                if other.infect(infectant, timestamp, disease_parameters):
                    result += [other]

        return result

    def reset(self):
        &#34;&#34;&#34;
        TODO Docstring Group reset
        &#34;&#34;&#34;

        self.members = np.array([])
        self.counter = Counter(0)

    @staticmethod
    def move(members: iter, origin: &#39;Group&#39;, destination: &#39;Group&#39;):
        &#34;&#34;&#34;
        TODO Docstring Group move
        &#34;&#34;&#34;

        for member in members:
            origin.remove_member(member)
            destination.add_member(member)

    @property
    def history(self):
        return self.counter.history

    @property
    def size(self):
        return self.members.size


################################################################################################
################################################################################################
################################################################################################


class Household(Group):
    def __init__(self, identifier: int):
        &#34;&#34;&#34;
        TODO Docstring Household __init__
        &#34;&#34;&#34;

        super().__init__(str(identifier))

    @property
    def id(self):
        return self.name


################################################################################################
################################################################################################
################################################################################################


class Population(Group):
    def __init__(self, name: str):
        &#34;&#34;&#34;
        TODO Docstring Population __init__
        &#34;&#34;&#34;

        super().__init__(name)
        self.households = {}

    def add_member(self, member: Member, count: int = True):
        &#34;&#34;&#34;
        Adds member as a Member to the Population
        and to its Household within the Population.

        Parameters
        ----------
        member : Member
            The Member to be added to the Population.
        count :
            Option whether to increase population counter or not.

        Raises
        ------
        KeyError
            member is expected to have the property &#39;household&#39;.
            If member does not meet the expectations,
            a KeyError will be raised.

        Returns
        -------
        None.
        &#34;&#34;&#34;

        household_id = member.properties[&#34;household&#34;]
        if household_id in self.households.keys():
            self.households[household_id].add_member(member)
        else:
            household = Household(household_id)
            self.households[household_id] = household
            self.households[household_id].add_member(member)

        if type(self.members) == np.ndarray:
            self.members = np.append(self.members, member)
        else:
            self.members += [member]

        self.counter.increment()

    def save_as_json(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        TODO Docstring Population save_as_json
        &#34;&#34;&#34;

        if len(self.members) == 0:
            raise ValueError(&#34;Population can&#39;t be empty.&#34;)

        with open(path + &#34;population.json&#34;, &#39;w&#39;) as f:
            wrapper = &#34;{\n\t\&#34;name\&#34;: \&#34;&#34; + self.name + &#34;\&#34;,\n\t\&#34;size\&#34;: &#34; + str(self.size) + &#34;,\n\t\&#34;members\&#34;: [\n&#34;
            inner = &#34;&#34;
            for member in self:
                json_str = json.dumps(member.properties, indent=4)
                inner += json_str + &#39;, \n&#39;

            inner = textwrap.indent(inner[:-3] + &#39;\n&#39;, &#39;\t\t&#39;)

            f.write(wrapper + inner + &#34;\t]\n}&#34;)
            f.close()

    def copy(self):
        &#34;&#34;&#34;
        TODO Docstring Population copy
        &#34;&#34;&#34;

        p = Population(self.name)
        p.members = list(p.members)
        for member in self.members:
            p.add_member(member.copy())

        p.members = np.array(p.members)
        p.counter = self.counter.copy()

        return p

    @staticmethod
    def load_from_csv(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv.
        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        p : Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-4])
        p.members = []
        with open(path + file_name, newline=&#39;&#39;) as f:
            progress = ProgressBar(1, 1, sum(1 for _ in f) - 1)

        print(&#34;Loading population data...&#34;)

        progress.update(0)
        with open(path + file_name, newline=&#39;&#39;) as f:
            for m_dict in csv.DictReader(f):
                progress.update(1)
                p.add_member(Member(m_dict))

        print(&#34;\nFinished loading.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_json(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .json.
        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        p : Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-5])
        p.members = []
        with open(path + file_name, &#34;r&#34;) as f:
            print(&#34;Load json...&#34;)
            data = json.load(f)
            print(&#34;Finished loading.\n\nAdding members to population...&#34;)

            progress = ProgressBar(1, 1, len(data[&#34;members&#34;]))
            progress.update(0)
            for member in data[&#34;members&#34;]:
                progress.update(1)
                p.add_member(Member(member))

            print(&#34;\nFinished adding members.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_file(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv or .json.
        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Raises
        ------
        ValueError
            file_name is expected to end in .csv or .json.
            If file_name does not meet the expectation,
            a ValueError will be raised.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        if file_name[-4:] == &#34;.csv&#34;:
            return Population.load_from_csv(file_name, path)
        elif file_name[-5:] == &#34;.json&#34;:
            return Population.load_from_json(file_name, path)
        else:
            raise ValueError(&#34;file_name must end in .csv or .json.&#34;)


################################################################################################
################################################################################################
################################################################################################</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Network.Group"><code class="flex name class">
<span>class <span class="ident">Group</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Group <strong>init</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Group:
    def __init__(self, name: str):
        &#34;&#34;&#34;
        TODO Docstring Group __init__
        &#34;&#34;&#34;

        self.name = name
        self.members = np.array([])
        self.counter = Counter(0)

    def __str__(self):
        result = self.__class__.__name__ + &#34;: &#34; + self.name + &#34;\nMembers: &#34;
        for member in self:
            result += str(member) + &#34;\n\t\t &#34;

        return result[:-1]

    def __iter__(self):
        return iter(self.members)

    def add_member(self, member: Member):
        &#34;&#34;&#34;
        TODO Docstring Group add_member
        &#34;&#34;&#34;

        self.members = np.append(self.members, member)
        self.counter.increment()

    def remove_member(self, member: Member):
        &#34;&#34;&#34;
        TODO Docstring Group remove_member
        &#34;&#34;&#34;

        old_size = self.members.size
        self.members = self.members[self.members != member]
        self.counter.decrement(old_size - self.members.size)

    def spread_disease(self, infectant: Member, n: int, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        TODO Docstring Group spread_disease
        &#34;&#34;&#34;

        result = []
        for other in np.random.choice(self.members, n):
            if infectant.properties[&#34;id&#34;] == other.properties[&#34;id&#34;]:
                continue

            infectant.add_to_contacts(other)

            if np.random.uniform() &lt; disease_parameters[&#34;infection_probability_heuristic&#34;](other.properties):
                if other.infect(infectant, timestamp, disease_parameters):
                    result += [other]

        return result

    def reset(self):
        &#34;&#34;&#34;
        TODO Docstring Group reset
        &#34;&#34;&#34;

        self.members = np.array([])
        self.counter = Counter(0)

    @staticmethod
    def move(members: iter, origin: &#39;Group&#39;, destination: &#39;Group&#39;):
        &#34;&#34;&#34;
        TODO Docstring Group move
        &#34;&#34;&#34;

        for member in members:
            origin.remove_member(member)
            destination.add_member(member)

    @property
    def history(self):
        return self.counter.history

    @property
    def size(self):
        return self.members.size</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.Network.Household" href="#src.Network.Household">Household</a></li>
<li><a title="src.Network.Population" href="#src.Network.Population">Population</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="src.Network.Group.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>members: <built-in function iter>, origin: <a title="src.Network.Group" href="#src.Network.Group">Group</a>, destination: <a title="src.Network.Group" href="#src.Network.Group">Group</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Group move</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def move(members: iter, origin: &#39;Group&#39;, destination: &#39;Group&#39;):
    &#34;&#34;&#34;
    TODO Docstring Group move
    &#34;&#34;&#34;

    for member in members:
        origin.remove_member(member)
        destination.add_member(member)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="src.Network.Group.history"><code class="name">var <span class="ident">history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def history(self):
    return self.counter.history</code></pre>
</details>
</dd>
<dt id="src.Network.Group.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.members.size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.Network.Group.add_member"><code class="name flex">
<span>def <span class="ident">add_member</span></span>(<span>self, member: <a title="src.Network.Member" href="#src.Network.Member">Member</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Group add_member</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_member(self, member: Member):
    &#34;&#34;&#34;
    TODO Docstring Group add_member
    &#34;&#34;&#34;

    self.members = np.append(self.members, member)
    self.counter.increment()</code></pre>
</details>
</dd>
<dt id="src.Network.Group.remove_member"><code class="name flex">
<span>def <span class="ident">remove_member</span></span>(<span>self, member: <a title="src.Network.Member" href="#src.Network.Member">Member</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Group remove_member</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_member(self, member: Member):
    &#34;&#34;&#34;
    TODO Docstring Group remove_member
    &#34;&#34;&#34;

    old_size = self.members.size
    self.members = self.members[self.members != member]
    self.counter.decrement(old_size - self.members.size)</code></pre>
</details>
</dd>
<dt id="src.Network.Group.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Group reset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;
    TODO Docstring Group reset
    &#34;&#34;&#34;

    self.members = np.array([])
    self.counter = Counter(0)</code></pre>
</details>
</dd>
<dt id="src.Network.Group.spread_disease"><code class="name flex">
<span>def <span class="ident">spread_disease</span></span>(<span>self, infectant: <a title="src.Network.Member" href="#src.Network.Member">Member</a>, n: int, timestamp: int, disease_parameters: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Group spread_disease</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spread_disease(self, infectant: Member, n: int, timestamp: int, disease_parameters: dict):
    &#34;&#34;&#34;
    TODO Docstring Group spread_disease
    &#34;&#34;&#34;

    result = []
    for other in np.random.choice(self.members, n):
        if infectant.properties[&#34;id&#34;] == other.properties[&#34;id&#34;]:
            continue

        infectant.add_to_contacts(other)

        if np.random.uniform() &lt; disease_parameters[&#34;infection_probability_heuristic&#34;](other.properties):
            if other.infect(infectant, timestamp, disease_parameters):
                result += [other]

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.Network.Household"><code class="flex name class">
<span>class <span class="ident">Household</span></span>
<span>(</span><span>identifier: int)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Household <strong>init</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Household(Group):
    def __init__(self, identifier: int):
        &#34;&#34;&#34;
        TODO Docstring Household __init__
        &#34;&#34;&#34;

        super().__init__(str(identifier))

    @property
    def id(self):
        return self.name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.Network.Group" href="#src.Network.Group">Group</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="src.Network.Household.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    return self.name</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.Network.Group" href="#src.Network.Group">Group</a></b></code>:
<ul class="hlist">
<li><code><a title="src.Network.Group.add_member" href="#src.Network.Group.add_member">add_member</a></code></li>
<li><code><a title="src.Network.Group.move" href="#src.Network.Group.move">move</a></code></li>
<li><code><a title="src.Network.Group.remove_member" href="#src.Network.Group.remove_member">remove_member</a></code></li>
<li><code><a title="src.Network.Group.reset" href="#src.Network.Group.reset">reset</a></code></li>
<li><code><a title="src.Network.Group.spread_disease" href="#src.Network.Group.spread_disease">spread_disease</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="src.Network.Member"><code class="flex name class">
<span>class <span class="ident">Member</span></span>
<span>(</span><span>properties: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member <strong>init</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Member:
    def __init__(self, properties: dict):
        &#34;&#34;&#34;
        TODO Docstring Member __init__
        &#34;&#34;&#34;

        def check(_properties: dict):
            must_haves = [&#34;id&#34;, &#34;household&#34;]

            for property in must_haves:
                if property not in _properties.keys():
                    raise KeyError(&#34;Properties have to contain &#39;&#34; + property + &#34;&#39;.&#34;)

            return _properties

        self.properties = check(properties)
        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self.dead = False
        self.immune = False
        self.quarantined = False
        self.recent_contacts = []
        self._susceptible_in = -1
        self._infectious_in = -1
        self._recovers_in = -1
        self._immune_in = -1
        self._released_in = -1
        self._last_tested = -1

    def __str__(self):
        return &#34;\n&#34;.join([&#34;%s = %s&#34; % (attr, val) for attr, val in self.__dict__.items()])

    def infect(self, infectant: &#39;Member&#39;, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        TODO Docstring Member infect
        &#34;&#34;&#34;

        n_incubation = disease_parameters[&#34;incubation_period&#34;]
        n_infection = disease_parameters[&#34;infection_period&#34;]
        shared_household = self.properties[&#34;household&#34;] == infectant.properties[&#34;household&#34;]

        if (self.immune and not self.vaccinated) or self.infected or \
                self.dead or (self.quarantined and not shared_household):
            return False

        if self.vaccinated and self._immune_in &lt;= 0:
            p_failure = disease_parameters[&#34;vaccine_failure_probability_heuristic&#34;](self, timestamp)
            if np.random.uniform() &gt; p_failure:
                return False

        infection_data = [(infectant.properties[&#34;id&#34;],
                           shared_household,
                           timestamp,
                           timestamp + n_incubation,
                           timestamp + n_incubation + n_infection)]

        if &#34;infections&#34; not in self.properties.keys():
            self.properties[&#34;infections&#34;] = infection_data

        else:
            self.properties[&#34;infections&#34;] += infection_data

        self.infected = True
        self._infectious_in = n_incubation
        self._recovers_in = n_infection
        self._susceptible_in = disease_parameters[&#34;immunity_period&#34;]

        return True

    def vaccinate(self, timestamp: int, vaccine_parameters: dict):
        &#34;&#34;&#34;
        TODO Docstring Member vaccinate
        &#34;&#34;&#34;

        vaccine_unavailable = self.infected or self.dead or self.quarantined or \
                              &#34;vaccinations&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;vaccinations&#34;][-1][1] + vaccine_parameters[&#34;t_wait_vac&#34;] or \
                              &#34;infections&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;infections&#34;][-1][4] + vaccine_parameters[&#34;t_wait_rec&#34;]

        if not vaccine_unavailable:
            vaccination_data = [(timestamp,
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;],
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;] + vaccine_parameters[&#34;t_immunity&#34;])]

            if &#34;vaccinations&#34; in self.properties.keys():
                self.properties[&#34;vaccinations&#34;] += vaccination_data

            else:
                self.properties[&#34;vaccinations&#34;] = vaccination_data

            if self.immune:
                self._immune_in = 0
                self._susceptible_in = max(vaccine_parameters[&#34;t_immunity&#34;], self._susceptible_in)

            else:
                self._immune_in = vaccine_parameters[&#34;t_vac_effect&#34;]
                self._susceptible_in = vaccine_parameters[&#34;t_immunity&#34;]

            return True

        return False

    def test(self, timestamp: int):
        &#34;&#34;&#34;
        TODO Docstring Member test
        &#34;&#34;&#34;

        result = self.infected * (np.random.uniform() &lt; 0.99)

        if &#34;tests&#34; not in self.properties.keys():
            self.properties[&#34;tests&#34;] = [0, 0]

        self.properties[&#34;tests&#34;][result] += 1
        self._last_tested = timestamp

        return result

    def quarantine(self, days: int):
        &#34;&#34;&#34;
        TODO Docstring Member quarantine
        &#34;&#34;&#34;

        self.quarantined = True
        self._released_in = days

    def add_to_contacts(self, other):
        &#34;&#34;&#34;
        TODO Docstring Member add_to_contacts
        &#34;&#34;&#34;

        if len(self.recent_contacts) &lt; 5:
            self.recent_contacts += [other]

        else:
            self.recent_contacts = self.recent_contacts[1:] + [other]

    def make_immune(self, immunity_duration: int):
        &#34;&#34;&#34;
        TODO Docstring Member make_immune
        &#34;&#34;&#34;

        if self.infected:
            raise RuntimeError
            self.infected = False
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return True

        else:
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return False

    def make_dead(self, timestamp: int):
        &#34;&#34;&#34;
        TODO Docstring Member make_dead
        &#34;&#34;&#34;

        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self._susceptible_in = -1
        self._recovers_in = -1
        self._infectious_in = -1
        self._immune_in = -1

        self.dead = True
        self.properties[&#34;Death&#34;] = timestamp

    def make_tick(self, option: str, timestamp: int = None):
        &#34;&#34;&#34;
        TODO Docstring Member make_tick
        &#34;&#34;&#34;

        if option == &#34;infectious&#34;:
            if self._infectious_in &gt; 0:
                self._infectious_in -= 1

            return self._infectious_in &lt;= 0

        elif option == &#34;immunity&#34;:
            if self._immune_in &lt;= 0:
                self._susceptible_in -= 1
                if self._susceptible_in == 0:
                    self._susceptible_in = -1
                    self.immune = False
                    return True

            return False

        elif option == &#34;vaccine&#34;:
            self._immune_in -= 1
            if self._immune_in == 0:
                self.immune = True

        elif option == &#34;recover&#34;:
            self._recovers_in -= 1
            if self._recovers_in == 0:
                self._recovers_in = -1
                self.infected = False
                self.immune = True
                return True

            return False

        elif option == &#34;quarantine&#34;:
            self._released_in -= 1

            if &#34;days_in_quarantine&#34; not in self.properties.keys():
                self.properties[&#34;days_in_quarantine&#34;] = 0

            self.properties[&#34;days_in_quarantine&#34;] += 1

            if self._released_in == 0:
                if self.test(timestamp):
                    self._released_in += 5
                else:
                    self._released_in = -1
                    self.quarantined = False
                    return True

            return False

        else:
            raise ValueError(&#34;option not supported&#34;)

    def copy(self):
        &#34;&#34;&#34;
        TODO Docstring Member copy
        &#34;&#34;&#34;

        m = Member(self.properties.copy())
        m.infected = self.infected
        m.recovered = self.recovered
        m.vaccinated = self.vaccinated
        m.dead = self.dead
        m._susceptible_in = self._susceptible_in
        m._recovers_in = self._recovers_in
        m._infectious_in = self._infectious_in
        m._immune_in = self._immune_in

        return m</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.Network.Member.add_to_contacts"><code class="name flex">
<span>def <span class="ident">add_to_contacts</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member add_to_contacts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_contacts(self, other):
    &#34;&#34;&#34;
    TODO Docstring Member add_to_contacts
    &#34;&#34;&#34;

    if len(self.recent_contacts) &lt; 5:
        self.recent_contacts += [other]

    else:
        self.recent_contacts = self.recent_contacts[1:] + [other]</code></pre>
</details>
</dd>
<dt id="src.Network.Member.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    TODO Docstring Member copy
    &#34;&#34;&#34;

    m = Member(self.properties.copy())
    m.infected = self.infected
    m.recovered = self.recovered
    m.vaccinated = self.vaccinated
    m.dead = self.dead
    m._susceptible_in = self._susceptible_in
    m._recovers_in = self._recovers_in
    m._infectious_in = self._infectious_in
    m._immune_in = self._immune_in

    return m</code></pre>
</details>
</dd>
<dt id="src.Network.Member.infect"><code class="name flex">
<span>def <span class="ident">infect</span></span>(<span>self, infectant: <a title="src.Network.Member" href="#src.Network.Member">Member</a>, timestamp: int, disease_parameters: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member infect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infect(self, infectant: &#39;Member&#39;, timestamp: int, disease_parameters: dict):
    &#34;&#34;&#34;
    TODO Docstring Member infect
    &#34;&#34;&#34;

    n_incubation = disease_parameters[&#34;incubation_period&#34;]
    n_infection = disease_parameters[&#34;infection_period&#34;]
    shared_household = self.properties[&#34;household&#34;] == infectant.properties[&#34;household&#34;]

    if (self.immune and not self.vaccinated) or self.infected or \
            self.dead or (self.quarantined and not shared_household):
        return False

    if self.vaccinated and self._immune_in &lt;= 0:
        p_failure = disease_parameters[&#34;vaccine_failure_probability_heuristic&#34;](self, timestamp)
        if np.random.uniform() &gt; p_failure:
            return False

    infection_data = [(infectant.properties[&#34;id&#34;],
                       shared_household,
                       timestamp,
                       timestamp + n_incubation,
                       timestamp + n_incubation + n_infection)]

    if &#34;infections&#34; not in self.properties.keys():
        self.properties[&#34;infections&#34;] = infection_data

    else:
        self.properties[&#34;infections&#34;] += infection_data

    self.infected = True
    self._infectious_in = n_incubation
    self._recovers_in = n_infection
    self._susceptible_in = disease_parameters[&#34;immunity_period&#34;]

    return True</code></pre>
</details>
</dd>
<dt id="src.Network.Member.make_dead"><code class="name flex">
<span>def <span class="ident">make_dead</span></span>(<span>self, timestamp: int)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member make_dead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_dead(self, timestamp: int):
    &#34;&#34;&#34;
    TODO Docstring Member make_dead
    &#34;&#34;&#34;

    self.infected = False
    self.recovered = False
    self.vaccinated = False
    self._susceptible_in = -1
    self._recovers_in = -1
    self._infectious_in = -1
    self._immune_in = -1

    self.dead = True
    self.properties[&#34;Death&#34;] = timestamp</code></pre>
</details>
</dd>
<dt id="src.Network.Member.make_immune"><code class="name flex">
<span>def <span class="ident">make_immune</span></span>(<span>self, immunity_duration: int)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member make_immune</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_immune(self, immunity_duration: int):
    &#34;&#34;&#34;
    TODO Docstring Member make_immune
    &#34;&#34;&#34;

    if self.infected:
        raise RuntimeError
        self.infected = False
        self._infectious_in = -1
        self._recovers_in = -1
        self._susceptible_in = immunity_duration
        self.immune = True
        return True

    else:
        self._infectious_in = -1
        self._recovers_in = -1
        self._susceptible_in = immunity_duration
        self.immune = True
        return False</code></pre>
</details>
</dd>
<dt id="src.Network.Member.make_tick"><code class="name flex">
<span>def <span class="ident">make_tick</span></span>(<span>self, option: str, timestamp: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member make_tick</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_tick(self, option: str, timestamp: int = None):
    &#34;&#34;&#34;
    TODO Docstring Member make_tick
    &#34;&#34;&#34;

    if option == &#34;infectious&#34;:
        if self._infectious_in &gt; 0:
            self._infectious_in -= 1

        return self._infectious_in &lt;= 0

    elif option == &#34;immunity&#34;:
        if self._immune_in &lt;= 0:
            self._susceptible_in -= 1
            if self._susceptible_in == 0:
                self._susceptible_in = -1
                self.immune = False
                return True

        return False

    elif option == &#34;vaccine&#34;:
        self._immune_in -= 1
        if self._immune_in == 0:
            self.immune = True

    elif option == &#34;recover&#34;:
        self._recovers_in -= 1
        if self._recovers_in == 0:
            self._recovers_in = -1
            self.infected = False
            self.immune = True
            return True

        return False

    elif option == &#34;quarantine&#34;:
        self._released_in -= 1

        if &#34;days_in_quarantine&#34; not in self.properties.keys():
            self.properties[&#34;days_in_quarantine&#34;] = 0

        self.properties[&#34;days_in_quarantine&#34;] += 1

        if self._released_in == 0:
            if self.test(timestamp):
                self._released_in += 5
            else:
                self._released_in = -1
                self.quarantined = False
                return True

        return False

    else:
        raise ValueError(&#34;option not supported&#34;)</code></pre>
</details>
</dd>
<dt id="src.Network.Member.quarantine"><code class="name flex">
<span>def <span class="ident">quarantine</span></span>(<span>self, days: int)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member quarantine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quarantine(self, days: int):
    &#34;&#34;&#34;
    TODO Docstring Member quarantine
    &#34;&#34;&#34;

    self.quarantined = True
    self._released_in = days</code></pre>
</details>
</dd>
<dt id="src.Network.Member.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, timestamp: int)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member test</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(self, timestamp: int):
    &#34;&#34;&#34;
    TODO Docstring Member test
    &#34;&#34;&#34;

    result = self.infected * (np.random.uniform() &lt; 0.99)

    if &#34;tests&#34; not in self.properties.keys():
        self.properties[&#34;tests&#34;] = [0, 0]

    self.properties[&#34;tests&#34;][result] += 1
    self._last_tested = timestamp

    return result</code></pre>
</details>
</dd>
<dt id="src.Network.Member.vaccinate"><code class="name flex">
<span>def <span class="ident">vaccinate</span></span>(<span>self, timestamp: int, vaccine_parameters: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Member vaccinate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vaccinate(self, timestamp: int, vaccine_parameters: dict):
    &#34;&#34;&#34;
    TODO Docstring Member vaccinate
    &#34;&#34;&#34;

    vaccine_unavailable = self.infected or self.dead or self.quarantined or \
                          &#34;vaccinations&#34; in self.properties.keys() and \
                          timestamp &lt; self.properties[&#34;vaccinations&#34;][-1][1] + vaccine_parameters[&#34;t_wait_vac&#34;] or \
                          &#34;infections&#34; in self.properties.keys() and \
                          timestamp &lt; self.properties[&#34;infections&#34;][-1][4] + vaccine_parameters[&#34;t_wait_rec&#34;]

    if not vaccine_unavailable:
        vaccination_data = [(timestamp,
                             timestamp + vaccine_parameters[&#34;t_vac_effect&#34;],
                             timestamp + vaccine_parameters[&#34;t_vac_effect&#34;] + vaccine_parameters[&#34;t_immunity&#34;])]

        if &#34;vaccinations&#34; in self.properties.keys():
            self.properties[&#34;vaccinations&#34;] += vaccination_data

        else:
            self.properties[&#34;vaccinations&#34;] = vaccination_data

        if self.immune:
            self._immune_in = 0
            self._susceptible_in = max(vaccine_parameters[&#34;t_immunity&#34;], self._susceptible_in)

        else:
            self._immune_in = vaccine_parameters[&#34;t_vac_effect&#34;]
            self._susceptible_in = vaccine_parameters[&#34;t_immunity&#34;]

        return True

    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.Network.Population"><code class="flex name class">
<span>class <span class="ident">Population</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Population <strong>init</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Population(Group):
    def __init__(self, name: str):
        &#34;&#34;&#34;
        TODO Docstring Population __init__
        &#34;&#34;&#34;

        super().__init__(name)
        self.households = {}

    def add_member(self, member: Member, count: int = True):
        &#34;&#34;&#34;
        Adds member as a Member to the Population
        and to its Household within the Population.

        Parameters
        ----------
        member : Member
            The Member to be added to the Population.
        count :
            Option whether to increase population counter or not.

        Raises
        ------
        KeyError
            member is expected to have the property &#39;household&#39;.
            If member does not meet the expectations,
            a KeyError will be raised.

        Returns
        -------
        None.
        &#34;&#34;&#34;

        household_id = member.properties[&#34;household&#34;]
        if household_id in self.households.keys():
            self.households[household_id].add_member(member)
        else:
            household = Household(household_id)
            self.households[household_id] = household
            self.households[household_id].add_member(member)

        if type(self.members) == np.ndarray:
            self.members = np.append(self.members, member)
        else:
            self.members += [member]

        self.counter.increment()

    def save_as_json(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        TODO Docstring Population save_as_json
        &#34;&#34;&#34;

        if len(self.members) == 0:
            raise ValueError(&#34;Population can&#39;t be empty.&#34;)

        with open(path + &#34;population.json&#34;, &#39;w&#39;) as f:
            wrapper = &#34;{\n\t\&#34;name\&#34;: \&#34;&#34; + self.name + &#34;\&#34;,\n\t\&#34;size\&#34;: &#34; + str(self.size) + &#34;,\n\t\&#34;members\&#34;: [\n&#34;
            inner = &#34;&#34;
            for member in self:
                json_str = json.dumps(member.properties, indent=4)
                inner += json_str + &#39;, \n&#39;

            inner = textwrap.indent(inner[:-3] + &#39;\n&#39;, &#39;\t\t&#39;)

            f.write(wrapper + inner + &#34;\t]\n}&#34;)
            f.close()

    def copy(self):
        &#34;&#34;&#34;
        TODO Docstring Population copy
        &#34;&#34;&#34;

        p = Population(self.name)
        p.members = list(p.members)
        for member in self.members:
            p.add_member(member.copy())

        p.members = np.array(p.members)
        p.counter = self.counter.copy()

        return p

    @staticmethod
    def load_from_csv(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv.
        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        p : Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-4])
        p.members = []
        with open(path + file_name, newline=&#39;&#39;) as f:
            progress = ProgressBar(1, 1, sum(1 for _ in f) - 1)

        print(&#34;Loading population data...&#34;)

        progress.update(0)
        with open(path + file_name, newline=&#39;&#39;) as f:
            for m_dict in csv.DictReader(f):
                progress.update(1)
                p.add_member(Member(m_dict))

        print(&#34;\nFinished loading.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_json(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .json.
        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        p : Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-5])
        p.members = []
        with open(path + file_name, &#34;r&#34;) as f:
            print(&#34;Load json...&#34;)
            data = json.load(f)
            print(&#34;Finished loading.\n\nAdding members to population...&#34;)

            progress = ProgressBar(1, 1, len(data[&#34;members&#34;]))
            progress.update(0)
            for member in data[&#34;members&#34;]:
                progress.update(1)
                p.add_member(Member(member))

            print(&#34;\nFinished adding members.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_file(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv or .json.
        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Raises
        ------
        ValueError
            file_name is expected to end in .csv or .json.
            If file_name does not meet the expectation,
            a ValueError will be raised.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        if file_name[-4:] == &#34;.csv&#34;:
            return Population.load_from_csv(file_name, path)
        elif file_name[-5:] == &#34;.json&#34;:
            return Population.load_from_json(file_name, path)
        else:
            raise ValueError(&#34;file_name must end in .csv or .json.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.Network.Group" href="#src.Network.Group">Group</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="src.Network.Population.load_from_csv"><code class="name flex">
<span>def <span class="ident">load_from_csv</span></span>(<span>file_name: str, path: str = 'Populations/')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Population object according to the data given in file_name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file containing the data of the population.
Expected to end in .csv.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file named file_name.
The default is "Populations" + sep.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></dt>
<dd>A Population object containing the data for the given file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_csv(file_name: str, path: str = &#34;Populations&#34; + sep):
    &#34;&#34;&#34;
    Create a Population object according to the data given in file_name.

    Parameters
    ----------
    file_name : str
        The name of the file containing the data of the population.
        Expected to end in .csv.
    path : str, optional
        The path to the file named file_name.
        The default is &#34;Populations&#34; + sep.

    Returns
    -------
    p : Population
        A Population object containing the data for the given file.
    &#34;&#34;&#34;

    p = Population(file_name[:-4])
    p.members = []
    with open(path + file_name, newline=&#39;&#39;) as f:
        progress = ProgressBar(1, 1, sum(1 for _ in f) - 1)

    print(&#34;Loading population data...&#34;)

    progress.update(0)
    with open(path + file_name, newline=&#39;&#39;) as f:
        for m_dict in csv.DictReader(f):
            progress.update(1)
            p.add_member(Member(m_dict))

    print(&#34;\nFinished loading.&#34;)

    p.members = np.array(p.members)
    p.counter.squash_history()
    return p</code></pre>
</details>
</dd>
<dt id="src.Network.Population.load_from_file"><code class="name flex">
<span>def <span class="ident">load_from_file</span></span>(<span>file_name: str, path: str = 'Populations/')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Population object according to the data given in file_name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file containing the data of the population.
Expected to end in .csv or .json.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file named file_name.
The default is "Populations" + sep.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>file_name is expected to end in .csv or .json.
If file_name does not meet the expectation,
a ValueError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></dt>
<dd>A Population object containing the data for the given file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_file(file_name: str, path: str = &#34;Populations&#34; + sep):
    &#34;&#34;&#34;
    Create a Population object according to the data given in file_name.

    Parameters
    ----------
    file_name : str
        The name of the file containing the data of the population.
        Expected to end in .csv or .json.
    path : str, optional
        The path to the file named file_name.
        The default is &#34;Populations&#34; + sep.

    Raises
    ------
    ValueError
        file_name is expected to end in .csv or .json.
        If file_name does not meet the expectation,
        a ValueError will be raised.

    Returns
    -------
    Population
        A Population object containing the data for the given file.
    &#34;&#34;&#34;

    if file_name[-4:] == &#34;.csv&#34;:
        return Population.load_from_csv(file_name, path)
    elif file_name[-5:] == &#34;.json&#34;:
        return Population.load_from_json(file_name, path)
    else:
        raise ValueError(&#34;file_name must end in .csv or .json.&#34;)</code></pre>
</details>
</dd>
<dt id="src.Network.Population.load_from_json"><code class="name flex">
<span>def <span class="ident">load_from_json</span></span>(<span>file_name: str, path: str = 'Populations/')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Population object according to the data given in file_name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file containing the data of the population.
Expected to end in .json.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file named file_name.
The default is "Populations" + sep.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></dt>
<dd>A Population object containing the data for the given file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_json(file_name: str, path: str = &#34;Populations&#34; + sep):
    &#34;&#34;&#34;
    Create a Population object according to the data given in file_name.

    Parameters
    ----------
    file_name : str
        The name of the file containing the data of the population.
        Expected to end in .json.
    path : str, optional
        The path to the file named file_name.
        The default is &#34;Populations&#34; + sep.

    Returns
    -------
    p : Population
        A Population object containing the data for the given file.
    &#34;&#34;&#34;

    p = Population(file_name[:-5])
    p.members = []
    with open(path + file_name, &#34;r&#34;) as f:
        print(&#34;Load json...&#34;)
        data = json.load(f)
        print(&#34;Finished loading.\n\nAdding members to population...&#34;)

        progress = ProgressBar(1, 1, len(data[&#34;members&#34;]))
        progress.update(0)
        for member in data[&#34;members&#34;]:
            progress.update(1)
            p.add_member(Member(member))

        print(&#34;\nFinished adding members.&#34;)

    p.members = np.array(p.members)
    p.counter.squash_history()
    return p</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.Network.Population.add_member"><code class="name flex">
<span>def <span class="ident">add_member</span></span>(<span>self, member: <a title="src.Network.Member" href="#src.Network.Member">Member</a>, count: int = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds member as a Member to the Population
and to its Household within the Population.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a title="src.Network.Member" href="#src.Network.Member">Member</a></code></dt>
<dd>The Member to be added to the Population.</dd>
</dl>
<p>count :
Option whether to increase population counter or not.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>member is expected to have the property 'household'.
If member does not meet the expectations,
a KeyError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_member(self, member: Member, count: int = True):
    &#34;&#34;&#34;
    Adds member as a Member to the Population
    and to its Household within the Population.

    Parameters
    ----------
    member : Member
        The Member to be added to the Population.
    count :
        Option whether to increase population counter or not.

    Raises
    ------
    KeyError
        member is expected to have the property &#39;household&#39;.
        If member does not meet the expectations,
        a KeyError will be raised.

    Returns
    -------
    None.
    &#34;&#34;&#34;

    household_id = member.properties[&#34;household&#34;]
    if household_id in self.households.keys():
        self.households[household_id].add_member(member)
    else:
        household = Household(household_id)
        self.households[household_id] = household
        self.households[household_id].add_member(member)

    if type(self.members) == np.ndarray:
        self.members = np.append(self.members, member)
    else:
        self.members += [member]

    self.counter.increment()</code></pre>
</details>
</dd>
<dt id="src.Network.Population.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Population copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    TODO Docstring Population copy
    &#34;&#34;&#34;

    p = Population(self.name)
    p.members = list(p.members)
    for member in self.members:
        p.add_member(member.copy())

    p.members = np.array(p.members)
    p.counter = self.counter.copy()

    return p</code></pre>
</details>
</dd>
<dt id="src.Network.Population.save_as_json"><code class="name flex">
<span>def <span class="ident">save_as_json</span></span>(<span>self, path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>TODO Docstring Population save_as_json</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as_json(self, path: str) -&gt; None:
    &#34;&#34;&#34;
    TODO Docstring Population save_as_json
    &#34;&#34;&#34;

    if len(self.members) == 0:
        raise ValueError(&#34;Population can&#39;t be empty.&#34;)

    with open(path + &#34;population.json&#34;, &#39;w&#39;) as f:
        wrapper = &#34;{\n\t\&#34;name\&#34;: \&#34;&#34; + self.name + &#34;\&#34;,\n\t\&#34;size\&#34;: &#34; + str(self.size) + &#34;,\n\t\&#34;members\&#34;: [\n&#34;
        inner = &#34;&#34;
        for member in self:
            json_str = json.dumps(member.properties, indent=4)
            inner += json_str + &#39;, \n&#39;

        inner = textwrap.indent(inner[:-3] + &#39;\n&#39;, &#39;\t\t&#39;)

        f.write(wrapper + inner + &#34;\t]\n}&#34;)
        f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.Network.Group" href="#src.Network.Group">Group</a></b></code>:
<ul class="hlist">
<li><code><a title="src.Network.Group.move" href="#src.Network.Group.move">move</a></code></li>
<li><code><a title="src.Network.Group.remove_member" href="#src.Network.Group.remove_member">remove_member</a></code></li>
<li><code><a title="src.Network.Group.reset" href="#src.Network.Group.reset">reset</a></code></li>
<li><code><a title="src.Network.Group.spread_disease" href="#src.Network.Group.spread_disease">spread_disease</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Network.Group" href="#src.Network.Group">Group</a></code></h4>
<ul class="two-column">
<li><code><a title="src.Network.Group.add_member" href="#src.Network.Group.add_member">add_member</a></code></li>
<li><code><a title="src.Network.Group.history" href="#src.Network.Group.history">history</a></code></li>
<li><code><a title="src.Network.Group.move" href="#src.Network.Group.move">move</a></code></li>
<li><code><a title="src.Network.Group.remove_member" href="#src.Network.Group.remove_member">remove_member</a></code></li>
<li><code><a title="src.Network.Group.reset" href="#src.Network.Group.reset">reset</a></code></li>
<li><code><a title="src.Network.Group.size" href="#src.Network.Group.size">size</a></code></li>
<li><code><a title="src.Network.Group.spread_disease" href="#src.Network.Group.spread_disease">spread_disease</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Network.Household" href="#src.Network.Household">Household</a></code></h4>
<ul class="">
<li><code><a title="src.Network.Household.id" href="#src.Network.Household.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Network.Member" href="#src.Network.Member">Member</a></code></h4>
<ul class="two-column">
<li><code><a title="src.Network.Member.add_to_contacts" href="#src.Network.Member.add_to_contacts">add_to_contacts</a></code></li>
<li><code><a title="src.Network.Member.copy" href="#src.Network.Member.copy">copy</a></code></li>
<li><code><a title="src.Network.Member.infect" href="#src.Network.Member.infect">infect</a></code></li>
<li><code><a title="src.Network.Member.make_dead" href="#src.Network.Member.make_dead">make_dead</a></code></li>
<li><code><a title="src.Network.Member.make_immune" href="#src.Network.Member.make_immune">make_immune</a></code></li>
<li><code><a title="src.Network.Member.make_tick" href="#src.Network.Member.make_tick">make_tick</a></code></li>
<li><code><a title="src.Network.Member.quarantine" href="#src.Network.Member.quarantine">quarantine</a></code></li>
<li><code><a title="src.Network.Member.test" href="#src.Network.Member.test">test</a></code></li>
<li><code><a title="src.Network.Member.vaccinate" href="#src.Network.Member.vaccinate">vaccinate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></h4>
<ul class="two-column">
<li><code><a title="src.Network.Population.add_member" href="#src.Network.Population.add_member">add_member</a></code></li>
<li><code><a title="src.Network.Population.copy" href="#src.Network.Population.copy">copy</a></code></li>
<li><code><a title="src.Network.Population.load_from_csv" href="#src.Network.Population.load_from_csv">load_from_csv</a></code></li>
<li><code><a title="src.Network.Population.load_from_file" href="#src.Network.Population.load_from_file">load_from_file</a></code></li>
<li><code><a title="src.Network.Population.load_from_json" href="#src.Network.Population.load_from_json">load_from_json</a></code></li>
<li><code><a title="src.Network.Population.save_as_json" href="#src.Network.Population.save_as_json">save_as_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>