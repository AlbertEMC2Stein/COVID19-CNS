<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.Network API documentation</title>
<meta name="description" content="Collection of the fundamental classes of the network-model of infection." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Network</code></h1>
</header>
<section id="section-intro">
<p>Collection of the fundamental classes of the network-model of infection.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Collection of the fundamental classes of the network-model of infection.
&#34;&#34;&#34;

__all__ = [&#39;Member&#39;, &#39;Household&#39;, &#39;Population&#39;, &#39;Group&#39;]

import textwrap
import numpy as np
import csv
import json
from os.path import sep
from src.Utils import ProgressBar, Counter


################################################################################################
################################################################################################
################################################################################################


class Member:
    def __init__(self, properties: dict):
        &#34;&#34;&#34;
        A representation of a person. Consists of a dict &#39;properties&#39;
        containing all relevant data on this person, several attributes used
        only within the simulation and some private counters used only in
        functions in the &#39;Member&#39;-class called during simulation.

        Create a new member with the given attributes in &#39;properties&#39;.

        Parameters
        ----------
        properties : dict
            Dictionary containing all pre-defined attributes of the new member.

        Raises
        ------
        KeyError
            The properties-dict is expected to contain the keys &#39;id&#39; and
            &#39;household&#39;. If properties does not meet the expectation,
            a KeyError will be raised.
        &#34;&#34;&#34;

        def check(_properties: dict):
            must_haves = [&#34;id&#34;, &#34;household&#34;]

            for property in must_haves:
                if property not in _properties.keys():
                    raise KeyError(&#34;Properties have to contain &#39;&#34; + property + &#34;&#39;.&#34;)

            return _properties

        self.properties = check(properties)
        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self.dead = False
        self.immune = False
        self.quarantined = False
        self.recent_contacts = []
        self._susceptible_in = -1
        self._infectious_in = -1
        self._recovers_in = -1
        self._immune_in = -1
        self._released_in = -1
        self._last_tested = -1

    def __str__(self):
        return &#34;\n&#34;.join([&#34;%s = %s&#34; % (attr, val) for attr, val in self.__dict__.items()])

    def infect(self, infectant: &#39;Member&#39;, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        Infect the member, if it is infectable.

        Parameters
        ----------
        infectant : &#39;Member&#39;
            The infectious member that infects the member on which &#39;infect&#39; is
            applied.

        timestamp : int
            Current day in the simulation.

        disease_parameters : dict
            Dictionary containing all relevant infection parameters.
            Is expected to contain the keys
            &#39;incubation_period&#39;,
            &#39;infection_period&#39;,
            &#39;vaccine_failure_probability_heuristic&#39;,
            &#39;immunity_period&#39;.

        Returns
        -------
        bool
            Whether the member has been infected.
        &#34;&#34;&#34;

        n_incubation = disease_parameters[&#34;incubation_period&#34;]
        n_infection = disease_parameters[&#34;infection_period&#34;]
        shared_household = self.properties[&#34;household&#34;] == infectant.properties[&#34;household&#34;]

        if (self.immune and not self.vaccinated) or self.infected or \
                self.dead or (self.quarantined and not shared_household):
            return False

        if self.vaccinated and self._immune_in &lt;= 0:
            p_failure = disease_parameters[&#34;vaccine_failure_probability_heuristic&#34;](self, timestamp)
            if np.random.uniform() &gt; p_failure:
                return False

        infection_data = [(infectant.properties[&#34;id&#34;],
                           shared_household,
                           timestamp,
                           timestamp + n_incubation,
                           timestamp + n_incubation + n_infection)]

        if &#34;infections&#34; not in self.properties.keys():
            self.properties[&#34;infections&#34;] = infection_data

        else:
            self.properties[&#34;infections&#34;] += infection_data

        self.infected = True
        self._infectious_in = n_incubation
        self._recovers_in = n_infection
        self._susceptible_in = disease_parameters[&#34;immunity_period&#34;]

        return True

    def vaccinate(self, timestamp: int, vaccine_parameters: dict):
        &#34;&#34;&#34;
        Vaccinate the member, if it is allowed to be vaccinated.

        Parameters
        ----------
        timestamp : int
            Current day in the simulation.

        vaccine_parameters : dict
            Dictionary containing all relevant vaccination parameters.
            Is expected to contain the keys
            &#39;t_wait_vac&#39;,
            &#39;t_wait_rec&#39;,
            &#39;t_vac_effect&#39;,
            &#39;t_immunity&#39;.

        Returns
        -------
        bool
            Whether the member has been vaccinated.
        &#34;&#34;&#34;

        vaccine_unavailable = self.infected or self.dead or self.quarantined or \
                              &#34;vaccinations&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;vaccinations&#34;][-1][1] + vaccine_parameters[&#34;t_wait_vac&#34;] or \
                              &#34;infections&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;infections&#34;][-1][4] + vaccine_parameters[&#34;t_wait_rec&#34;]

        if not vaccine_unavailable:
            vaccination_data = [(timestamp,
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;],
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;] + vaccine_parameters[&#34;t_immunity&#34;])]

            if &#34;vaccinations&#34; in self.properties.keys():
                self.properties[&#34;vaccinations&#34;] += vaccination_data

            else:
                self.properties[&#34;vaccinations&#34;] = vaccination_data

            if self.immune:
                self._immune_in = 0
                self._susceptible_in = max(vaccine_parameters[&#34;t_immunity&#34;], self._susceptible_in)

            else:
                self._immune_in = vaccine_parameters[&#34;t_vac_effect&#34;]
                self._susceptible_in = vaccine_parameters[&#34;t_immunity&#34;]

            return True

        return False

    def test(self, timestamp: int):
        &#34;&#34;&#34;
        Test the member for an infection.

        Parameters
        ----------
        timestamp : int
            Current day in the simulation.

        Returns
        -------
        bool
            Whether the test is positive.
        &#34;&#34;&#34;

        result = self.infected * (np.random.uniform() &lt; 0.99)

        if &#34;tests&#34; not in self.properties.keys():
            self.properties[&#34;tests&#34;] = [0, 0]

        self.properties[&#34;tests&#34;][result] += 1
        self._last_tested = timestamp

        return result

    def quarantine(self, days: int):
        &#34;&#34;&#34;
        Place the member in quarantine.

        Parameters
        ----------
        days : int
            Amount of days (in the simulation) the member has to stay in
            quarantine.
        &#34;&#34;&#34;

        self.quarantined = True
        self._released_in = days

    def add_to_contacts(self, other: &#39;Member&#39;):
        &#34;&#34;&#34;
        Add &#39;other&#39; to the list of recent contacts of the member.

        Parameters
        ----------
        other : &#39;Member&#39;
            The member which is to be added to the list of recent contacts of
            the member on which &#39;add_to_contacts&#39; is called.
        &#34;&#34;&#34;

        if len(self.recent_contacts) &lt; 5:
            self.recent_contacts += [other]

        else:
            self.recent_contacts = self.recent_contacts[1:] + [other]

    def make_immune(self, immunity_duration: int):
        &#34;&#34;&#34;
        Make the member immune.
        Not to be used in the simulation other than in the initialization of
        groups (&#39;put_inits_in_respective_group&#39; in &#39;initialize_groups&#39; in
        &#39;start_iteration&#39;in the Simulation-class).

        Parameters
        ----------
        immunity_duration : int
            Amount of days (in the simulation) the member is to be immune.

        Returns
        -------
        bool
            Whether the member was infected before it has been made immune.
            This should never be the case.
        &#34;&#34;&#34;

        if self.infected: # This should never be the case.
            print(&#34;THIS SHOULD NOT APPEAR ON CONSOLE&#34;)
            self.infected = False
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return True

        else:
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return False

    def make_dead(self, timestamp: int):
        &#34;&#34;&#34;
        Kill the member.

        Parameters
        ----------
        timestamp : int
            Current day in the simulation.
        &#34;&#34;&#34;

        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self._susceptible_in = -1
        self._recovers_in = -1
        self._infectious_in = -1
        self._immune_in = -1

        self.dead = True
        self.properties[&#34;Death&#34;] = timestamp

    def make_tick(self, option: str, timestamp: int = None):
        &#34;&#34;&#34;
        Update the private counters of the member depending on the group or the
        stage the member is in.

        Parameters
        ----------
        option : str
            The type of update to be made.
            
        timestamp : int, optional
            Current day in the simulation.
            The default is None.

        Raises
        ------
        ValueError
            The &#39;option&#39;-string is expected to be one of the following strings:
            &#39;infectious&#39;,
            &#39;immunity&#39;,
            &#39;vaccine&#39;,
            &#39;recover&#39;,
            &#39;quarantine&#39;.
            If &#39;option&#39; does not meet the expectation,
            a ValueError will be raised.

        Returns
        -------
        bool
            Whether a change of attributes has been reached.
            No returns if option is &#39;vaccine&#39;.
        &#34;&#34;&#34;

        if option == &#34;infectious&#34;:
            if self._infectious_in &gt; 0:
                self._infectious_in -= 1

            return self._infectious_in &lt;= 0

        elif option == &#34;immunity&#34;:
            if self._immune_in &lt;= 0:
                self._susceptible_in -= 1
                if self._susceptible_in == 0:
                    self._susceptible_in = -1
                    self.immune = False
                    return True

            return False

        elif option == &#34;vaccine&#34;:
            self._immune_in -= 1
            if self._immune_in == 0:
                self.immune = True

        elif option == &#34;recover&#34;:
            self._recovers_in -= 1
            if self._recovers_in == 0:
                self._recovers_in = -1
                self.infected = False
                self.immune = True
                return True

            return False

        elif option == &#34;quarantine&#34;:
            self._released_in -= 1

            if &#34;days_in_quarantine&#34; not in self.properties.keys():
                self.properties[&#34;days_in_quarantine&#34;] = 0

            self.properties[&#34;days_in_quarantine&#34;] += 1

            if self._released_in == 0:
                if self.test(timestamp):
                    self._released_in += 5
                else:
                    self._released_in = -1
                    self.quarantined = False
                    return True

            return False

        else:
            raise ValueError(&#34;option not supported&#34;)

    def copy(self):
        &#34;&#34;&#34;
        Create a member as a copy of the member.
        (Deep copy)

        Returns
        -------
        Member
            The copy of the member.
        &#34;&#34;&#34;

        m = Member(self.properties.copy())
        m.infected = self.infected
        m.recovered = self.recovered
        m.vaccinated = self.vaccinated
        m.dead = self.dead
        m._susceptible_in = self._susceptible_in
        m._recovers_in = self._recovers_in
        m._infectious_in = self._infectious_in
        m._immune_in = self._immune_in

        return m


################################################################################################
################################################################################################
################################################################################################


class Group:
    def __init__(self, name: str):
        &#34;&#34;&#34;
        A base class for sets of several persons. Consists of a name-string,
        an array containing its members and a counter saving the amounts of
        members in the group.

        Create a new group named &#39;name&#39;.

        Parameters
        ----------
        name : str
            The name of the new group.
        &#34;&#34;&#34;

        self.name = name
        self.members = np.array([])
        self.counter = Counter(0)

    def __str__(self):
        result = self.__class__.__name__ + &#34;: &#34; + self.name + &#34;\nMembers: &#34;
        for member in self:
            result += str(member) + &#34;\n\t\t &#34;

        return result[:-1]

    def __iter__(self):
        return iter(self.members)

    def add_member(self, member: &#39;Member&#39;):
        &#34;&#34;&#34;
        Add &#39;member&#39; to the group.

        Parameters
        ----------
        member : Member
            The member to be added to the group.
        &#34;&#34;&#34;

        self.members = np.append(self.members, member)
        self.counter.increment()

    def remove_member(self, member: &#39;Member&#39;):
        &#34;&#34;&#34;
        Remove &#39;member&#39; from the group.

        Parameters
        ----------
        member : Member
            The member to be removed from the group.
        &#34;&#34;&#34;

        old_size = self.members.size
        self.members = self.members[self.members != member]
        self.counter.decrement(old_size - self.members.size)

    def spread_disease(self, infectant: &#39;Member&#39;, n: int, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        Let &#39;infectant&#39; infect randomly chosen members of the group.

        Parameters
        ----------
        infectant : &#39;Member&#39;
            The infectious member to be infecting members of the group.

        n : int
            The amount of members to be infected.

        timestamp : int
            Current day in the simulation.

        disease_parameters : dict
            Dictionary containing all relevant disease parameters.
            Is expected to contain the keys
            &#39;infection_probability_heuristic&#39;,
            &#39;incubation_period&#39;,
            &#39;infection_period&#39;,
            &#39;vaccine_failure_probability_heuristic&#39;,
            &#39;immunity_period&#39;.

        Returns
        -------
        list
            List of members which have been infected by &#39;infectant&#39;.
        &#34;&#34;&#34;

        result = []
        for other in np.random.choice(self.members, n):
            if infectant.properties[&#34;id&#34;] == other.properties[&#34;id&#34;]:
                continue

            infectant.add_to_contacts(other)

            if np.random.uniform() &lt; disease_parameters[&#34;infection_probability_heuristic&#34;](other.properties):
                if other.infect(infectant, timestamp, disease_parameters):
                    result += [other]

        return result

    def reset(self):
        &#34;&#34;&#34;
        Reset the group.
        &#34;&#34;&#34;

        self.members = np.array([])
        self.counter = Counter(0)

    @staticmethod
    def move(members: iter, origin: &#39;Group&#39;, destination: &#39;Group&#39;):
        &#34;&#34;&#34;
        Remove all members in &#39;members&#39; from &#39;origin&#39; and add them to
        &#39;destination&#39;.

        Parameters
        ----------
        members : iter
            Iterable of members to be moved from &#39;origin&#39; to &#39;destination&#39;.

        origin : Group
            Group from which the members in &#39;members&#39; are to be removed.

        destination : Group
            Group to which the members i &#39;members&#39; are to be added.
        &#34;&#34;&#34;

        for member in members:
            origin.remove_member(member)
            destination.add_member(member)

    @property
    def history(self):
        return self.counter.history

    @property
    def size(self):
        return self.members.size


################################################################################################
################################################################################################
################################################################################################


class Household(Group):
    def __init__(self, identifier: int):
        &#34;&#34;&#34;
        A representation of a household of people. A subclass of Group, where
        the name is the string of the household-id.

        Create a new household with household-id &#39;identifier&#39;.

        Parameters
        ----------
        identifier : int
            The id of the new household.
        &#34;&#34;&#34;

        super().__init__(str(identifier))

    @property
    def id(self):
        return self.name


################################################################################################
################################################################################################
################################################################################################


class Population(Group):
    def __init__(self, name: str):
        &#34;&#34;&#34;
        A representation of a larger set of people from several households.
        A subclass of Group, additionally consisting of a list of households.
        
        Create a new population named &#39;name&#39;.

        Parameters
        ----------
        name : str
            The name of the new population.
        &#34;&#34;&#34;

        super().__init__(name)
        self.households = {}

    def add_member(self, member: &#39;Member&#39;):
        &#34;&#34;&#34;
        Add &#39;member&#39; as a Member to the Population
        and to its Household within the Population.

        Parameters
        ----------
        member : Member
            The member to be added to the Population.

        Raises
        ------
        KeyError
            The member &#39;member&#39; is expected to have the property &#39;household&#39;.
            If &#39;member&#39; does not meet the expectations,
            a KeyError will be raised.
        &#34;&#34;&#34;

        household_id = member.properties[&#34;household&#34;]
        if household_id in self.households.keys():
            self.households[household_id].add_member(member)
        else:
            household = Household(household_id)
            self.households[household_id] = household
            self.households[household_id].add_member(member)

        if type(self.members) == np.ndarray:
            self.members = np.append(self.members, member)
        else:
            self.members += [member]

        self.counter.increment()

    def save_as_json(self, path: str):
        &#34;&#34;&#34;
        Save the population as population.json at the given &#39;path&#39;.

        Parameters
        ----------
        path : str
            The path at which the population-file is to be saved.

        Raises
        ------
        ValueError
            The population is expected to contain members.
            If the population does not meet the expectation,
            a ValueError will be raised.
        &#34;&#34;&#34;

        if len(self.members) == 0:
            raise ValueError(&#34;Population can&#39;t be empty.&#34;)

        with open(path + &#34;population.json&#34;, &#39;w&#39;) as f:
            wrapper = &#34;{\n\t\&#34;name\&#34;: \&#34;&#34; + self.name + &#34;\&#34;,\n\t\&#34;size\&#34;: &#34; + str(self.size) + &#34;,\n\t\&#34;members\&#34;: [\n&#34;
            inner = &#34;&#34;
            for member in self:
                json_str = json.dumps(member.properties, indent=4)
                inner += json_str + &#39;, \n&#39;

            inner = textwrap.indent(inner[:-3] + &#39;\n&#39;, &#39;\t\t&#39;)

            f.write(wrapper + inner + &#34;\t]\n}&#34;)
            f.close()

    def copy(self):
        &#34;&#34;&#34;
        Create a population as a copy of the population.
        (deep copy)

        Returns
        -------
        Population
            The copy of the population.
        &#34;&#34;&#34;

        p = Population(self.name)
        p.members = list(p.members)
        for member in self.members:
            p.add_member(member.copy())

        p.members = np.array(p.members)
        p.counter = self.counter.copy()

        return p

    @staticmethod
    def load_from_csv(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv.

        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-4])
        p.members = []
        with open(path + file_name, newline=&#39;&#39;) as f:
            progress = ProgressBar(1, sum(1 for _ in f) - 1)

        print(&#34;Loading population data...&#34;)

        progress.update(0)
        with open(path + file_name, newline=&#39;&#39;) as f:
            for m_dict in csv.DictReader(f):
                progress.update(1)
                p.add_member(Member(m_dict))

        print(&#34;\nFinished loading.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_json(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .json.

        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-5])
        p.members = []
        with open(path + file_name, &#34;r&#34;) as f:
            print(&#34;Load json...&#34;)
            data = json.load(f)
            print(&#34;Finished loading.\n\nAdding members to population...&#34;)

            progress = ProgressBar(1, len(data[&#34;members&#34;]))
            progress.update(0)
            for member in data[&#34;members&#34;]:
                progress.update(1)
                p.add_member(Member(member))

            print(&#34;\nFinished adding members.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_file(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv or .json.

        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Raises
        ------
        ValueError
            file_name is expected to end in .csv or .json.
            If file_name does not meet the expectation,
            a ValueError will be raised.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        if file_name[-4:] == &#34;.csv&#34;:
            return Population.load_from_csv(file_name, path)
        elif file_name[-5:] == &#34;.json&#34;:
            return Population.load_from_json(file_name, path)
        else:
            raise ValueError(&#34;file_name must end in .csv or .json.&#34;)


################################################################################################
################################################################################################
################################################################################################</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Network.Group"><code class="flex name class">
<span>class <span class="ident">Group</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for sets of several persons. Consists of a name-string,
an array containing its members and a counter saving the amounts of
members in the group.</p>
<p>Create a new group named 'name'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the new group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Group:
    def __init__(self, name: str):
        &#34;&#34;&#34;
        A base class for sets of several persons. Consists of a name-string,
        an array containing its members and a counter saving the amounts of
        members in the group.

        Create a new group named &#39;name&#39;.

        Parameters
        ----------
        name : str
            The name of the new group.
        &#34;&#34;&#34;

        self.name = name
        self.members = np.array([])
        self.counter = Counter(0)

    def __str__(self):
        result = self.__class__.__name__ + &#34;: &#34; + self.name + &#34;\nMembers: &#34;
        for member in self:
            result += str(member) + &#34;\n\t\t &#34;

        return result[:-1]

    def __iter__(self):
        return iter(self.members)

    def add_member(self, member: &#39;Member&#39;):
        &#34;&#34;&#34;
        Add &#39;member&#39; to the group.

        Parameters
        ----------
        member : Member
            The member to be added to the group.
        &#34;&#34;&#34;

        self.members = np.append(self.members, member)
        self.counter.increment()

    def remove_member(self, member: &#39;Member&#39;):
        &#34;&#34;&#34;
        Remove &#39;member&#39; from the group.

        Parameters
        ----------
        member : Member
            The member to be removed from the group.
        &#34;&#34;&#34;

        old_size = self.members.size
        self.members = self.members[self.members != member]
        self.counter.decrement(old_size - self.members.size)

    def spread_disease(self, infectant: &#39;Member&#39;, n: int, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        Let &#39;infectant&#39; infect randomly chosen members of the group.

        Parameters
        ----------
        infectant : &#39;Member&#39;
            The infectious member to be infecting members of the group.

        n : int
            The amount of members to be infected.

        timestamp : int
            Current day in the simulation.

        disease_parameters : dict
            Dictionary containing all relevant disease parameters.
            Is expected to contain the keys
            &#39;infection_probability_heuristic&#39;,
            &#39;incubation_period&#39;,
            &#39;infection_period&#39;,
            &#39;vaccine_failure_probability_heuristic&#39;,
            &#39;immunity_period&#39;.

        Returns
        -------
        list
            List of members which have been infected by &#39;infectant&#39;.
        &#34;&#34;&#34;

        result = []
        for other in np.random.choice(self.members, n):
            if infectant.properties[&#34;id&#34;] == other.properties[&#34;id&#34;]:
                continue

            infectant.add_to_contacts(other)

            if np.random.uniform() &lt; disease_parameters[&#34;infection_probability_heuristic&#34;](other.properties):
                if other.infect(infectant, timestamp, disease_parameters):
                    result += [other]

        return result

    def reset(self):
        &#34;&#34;&#34;
        Reset the group.
        &#34;&#34;&#34;

        self.members = np.array([])
        self.counter = Counter(0)

    @staticmethod
    def move(members: iter, origin: &#39;Group&#39;, destination: &#39;Group&#39;):
        &#34;&#34;&#34;
        Remove all members in &#39;members&#39; from &#39;origin&#39; and add them to
        &#39;destination&#39;.

        Parameters
        ----------
        members : iter
            Iterable of members to be moved from &#39;origin&#39; to &#39;destination&#39;.

        origin : Group
            Group from which the members in &#39;members&#39; are to be removed.

        destination : Group
            Group to which the members i &#39;members&#39; are to be added.
        &#34;&#34;&#34;

        for member in members:
            origin.remove_member(member)
            destination.add_member(member)

    @property
    def history(self):
        return self.counter.history

    @property
    def size(self):
        return self.members.size</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.Network.Household" href="#src.Network.Household">Household</a></li>
<li><a title="src.Network.Population" href="#src.Network.Population">Population</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="src.Network.Group.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>members: <built-in function iter>, origin: <a title="src.Network.Group" href="#src.Network.Group">Group</a>, destination: <a title="src.Network.Group" href="#src.Network.Group">Group</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all members in 'members' from 'origin' and add them to
'destination'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>members</code></strong> :&ensp;<code>iter</code></dt>
<dd>Iterable of members to be moved from 'origin' to 'destination'.</dd>
<dt><strong><code>origin</code></strong> :&ensp;<code><a title="src.Network.Group" href="#src.Network.Group">Group</a></code></dt>
<dd>Group from which the members in 'members' are to be removed.</dd>
<dt><strong><code>destination</code></strong> :&ensp;<code><a title="src.Network.Group" href="#src.Network.Group">Group</a></code></dt>
<dd>Group to which the members i 'members' are to be added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def move(members: iter, origin: &#39;Group&#39;, destination: &#39;Group&#39;):
    &#34;&#34;&#34;
    Remove all members in &#39;members&#39; from &#39;origin&#39; and add them to
    &#39;destination&#39;.

    Parameters
    ----------
    members : iter
        Iterable of members to be moved from &#39;origin&#39; to &#39;destination&#39;.

    origin : Group
        Group from which the members in &#39;members&#39; are to be removed.

    destination : Group
        Group to which the members i &#39;members&#39; are to be added.
    &#34;&#34;&#34;

    for member in members:
        origin.remove_member(member)
        destination.add_member(member)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="src.Network.Group.history"><code class="name">var <span class="ident">history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def history(self):
    return self.counter.history</code></pre>
</details>
</dd>
<dt id="src.Network.Group.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.members.size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.Network.Group.add_member"><code class="name flex">
<span>def <span class="ident">add_member</span></span>(<span>self, member: <a title="src.Network.Member" href="#src.Network.Member">Member</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add 'member' to the group.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a title="src.Network.Member" href="#src.Network.Member">Member</a></code></dt>
<dd>The member to be added to the group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_member(self, member: &#39;Member&#39;):
    &#34;&#34;&#34;
    Add &#39;member&#39; to the group.

    Parameters
    ----------
    member : Member
        The member to be added to the group.
    &#34;&#34;&#34;

    self.members = np.append(self.members, member)
    self.counter.increment()</code></pre>
</details>
</dd>
<dt id="src.Network.Group.remove_member"><code class="name flex">
<span>def <span class="ident">remove_member</span></span>(<span>self, member: <a title="src.Network.Member" href="#src.Network.Member">Member</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove 'member' from the group.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a title="src.Network.Member" href="#src.Network.Member">Member</a></code></dt>
<dd>The member to be removed from the group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_member(self, member: &#39;Member&#39;):
    &#34;&#34;&#34;
    Remove &#39;member&#39; from the group.

    Parameters
    ----------
    member : Member
        The member to be removed from the group.
    &#34;&#34;&#34;

    old_size = self.members.size
    self.members = self.members[self.members != member]
    self.counter.decrement(old_size - self.members.size)</code></pre>
</details>
</dd>
<dt id="src.Network.Group.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;
    Reset the group.
    &#34;&#34;&#34;

    self.members = np.array([])
    self.counter = Counter(0)</code></pre>
</details>
</dd>
<dt id="src.Network.Group.spread_disease"><code class="name flex">
<span>def <span class="ident">spread_disease</span></span>(<span>self, infectant: <a title="src.Network.Member" href="#src.Network.Member">Member</a>, n: int, timestamp: int, disease_parameters: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Let 'infectant' infect randomly chosen members of the group.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>infectant</code></strong> :&ensp;<code>'Member'</code></dt>
<dd>The infectious member to be infecting members of the group.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The amount of members to be infected.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code></dt>
<dd>Current day in the simulation.</dd>
<dt><strong><code>disease_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all relevant disease parameters.
Is expected to contain the keys
'infection_probability_heuristic',
'incubation_period',
'infection_period',
'vaccine_failure_probability_heuristic',
'immunity_period'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of members which have been infected by 'infectant'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spread_disease(self, infectant: &#39;Member&#39;, n: int, timestamp: int, disease_parameters: dict):
    &#34;&#34;&#34;
    Let &#39;infectant&#39; infect randomly chosen members of the group.

    Parameters
    ----------
    infectant : &#39;Member&#39;
        The infectious member to be infecting members of the group.

    n : int
        The amount of members to be infected.

    timestamp : int
        Current day in the simulation.

    disease_parameters : dict
        Dictionary containing all relevant disease parameters.
        Is expected to contain the keys
        &#39;infection_probability_heuristic&#39;,
        &#39;incubation_period&#39;,
        &#39;infection_period&#39;,
        &#39;vaccine_failure_probability_heuristic&#39;,
        &#39;immunity_period&#39;.

    Returns
    -------
    list
        List of members which have been infected by &#39;infectant&#39;.
    &#34;&#34;&#34;

    result = []
    for other in np.random.choice(self.members, n):
        if infectant.properties[&#34;id&#34;] == other.properties[&#34;id&#34;]:
            continue

        infectant.add_to_contacts(other)

        if np.random.uniform() &lt; disease_parameters[&#34;infection_probability_heuristic&#34;](other.properties):
            if other.infect(infectant, timestamp, disease_parameters):
                result += [other]

    return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.Network.Household"><code class="flex name class">
<span>class <span class="ident">Household</span></span>
<span>(</span><span>identifier: int)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of a household of people. A subclass of Group, where
the name is the string of the household-id.</p>
<p>Create a new household with household-id 'identifier'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the new household.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Household(Group):
    def __init__(self, identifier: int):
        &#34;&#34;&#34;
        A representation of a household of people. A subclass of Group, where
        the name is the string of the household-id.

        Create a new household with household-id &#39;identifier&#39;.

        Parameters
        ----------
        identifier : int
            The id of the new household.
        &#34;&#34;&#34;

        super().__init__(str(identifier))

    @property
    def id(self):
        return self.name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.Network.Group" href="#src.Network.Group">Group</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="src.Network.Household.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    return self.name</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.Network.Group" href="#src.Network.Group">Group</a></b></code>:
<ul class="hlist">
<li><code><a title="src.Network.Group.add_member" href="#src.Network.Group.add_member">add_member</a></code></li>
<li><code><a title="src.Network.Group.move" href="#src.Network.Group.move">move</a></code></li>
<li><code><a title="src.Network.Group.remove_member" href="#src.Network.Group.remove_member">remove_member</a></code></li>
<li><code><a title="src.Network.Group.reset" href="#src.Network.Group.reset">reset</a></code></li>
<li><code><a title="src.Network.Group.spread_disease" href="#src.Network.Group.spread_disease">spread_disease</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="src.Network.Member"><code class="flex name class">
<span>class <span class="ident">Member</span></span>
<span>(</span><span>properties: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of a person. Consists of a dict 'properties'
containing all relevant data on this person, several attributes used
only within the simulation and some private counters used only in
functions in the 'Member'-class called during simulation.</p>
<p>Create a new member with the given attributes in 'properties'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>properties</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all pre-defined attributes of the new member.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>The properties-dict is expected to contain the keys 'id' and
'household'. If properties does not meet the expectation,
a KeyError will be raised.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Member:
    def __init__(self, properties: dict):
        &#34;&#34;&#34;
        A representation of a person. Consists of a dict &#39;properties&#39;
        containing all relevant data on this person, several attributes used
        only within the simulation and some private counters used only in
        functions in the &#39;Member&#39;-class called during simulation.

        Create a new member with the given attributes in &#39;properties&#39;.

        Parameters
        ----------
        properties : dict
            Dictionary containing all pre-defined attributes of the new member.

        Raises
        ------
        KeyError
            The properties-dict is expected to contain the keys &#39;id&#39; and
            &#39;household&#39;. If properties does not meet the expectation,
            a KeyError will be raised.
        &#34;&#34;&#34;

        def check(_properties: dict):
            must_haves = [&#34;id&#34;, &#34;household&#34;]

            for property in must_haves:
                if property not in _properties.keys():
                    raise KeyError(&#34;Properties have to contain &#39;&#34; + property + &#34;&#39;.&#34;)

            return _properties

        self.properties = check(properties)
        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self.dead = False
        self.immune = False
        self.quarantined = False
        self.recent_contacts = []
        self._susceptible_in = -1
        self._infectious_in = -1
        self._recovers_in = -1
        self._immune_in = -1
        self._released_in = -1
        self._last_tested = -1

    def __str__(self):
        return &#34;\n&#34;.join([&#34;%s = %s&#34; % (attr, val) for attr, val in self.__dict__.items()])

    def infect(self, infectant: &#39;Member&#39;, timestamp: int, disease_parameters: dict):
        &#34;&#34;&#34;
        Infect the member, if it is infectable.

        Parameters
        ----------
        infectant : &#39;Member&#39;
            The infectious member that infects the member on which &#39;infect&#39; is
            applied.

        timestamp : int
            Current day in the simulation.

        disease_parameters : dict
            Dictionary containing all relevant infection parameters.
            Is expected to contain the keys
            &#39;incubation_period&#39;,
            &#39;infection_period&#39;,
            &#39;vaccine_failure_probability_heuristic&#39;,
            &#39;immunity_period&#39;.

        Returns
        -------
        bool
            Whether the member has been infected.
        &#34;&#34;&#34;

        n_incubation = disease_parameters[&#34;incubation_period&#34;]
        n_infection = disease_parameters[&#34;infection_period&#34;]
        shared_household = self.properties[&#34;household&#34;] == infectant.properties[&#34;household&#34;]

        if (self.immune and not self.vaccinated) or self.infected or \
                self.dead or (self.quarantined and not shared_household):
            return False

        if self.vaccinated and self._immune_in &lt;= 0:
            p_failure = disease_parameters[&#34;vaccine_failure_probability_heuristic&#34;](self, timestamp)
            if np.random.uniform() &gt; p_failure:
                return False

        infection_data = [(infectant.properties[&#34;id&#34;],
                           shared_household,
                           timestamp,
                           timestamp + n_incubation,
                           timestamp + n_incubation + n_infection)]

        if &#34;infections&#34; not in self.properties.keys():
            self.properties[&#34;infections&#34;] = infection_data

        else:
            self.properties[&#34;infections&#34;] += infection_data

        self.infected = True
        self._infectious_in = n_incubation
        self._recovers_in = n_infection
        self._susceptible_in = disease_parameters[&#34;immunity_period&#34;]

        return True

    def vaccinate(self, timestamp: int, vaccine_parameters: dict):
        &#34;&#34;&#34;
        Vaccinate the member, if it is allowed to be vaccinated.

        Parameters
        ----------
        timestamp : int
            Current day in the simulation.

        vaccine_parameters : dict
            Dictionary containing all relevant vaccination parameters.
            Is expected to contain the keys
            &#39;t_wait_vac&#39;,
            &#39;t_wait_rec&#39;,
            &#39;t_vac_effect&#39;,
            &#39;t_immunity&#39;.

        Returns
        -------
        bool
            Whether the member has been vaccinated.
        &#34;&#34;&#34;

        vaccine_unavailable = self.infected or self.dead or self.quarantined or \
                              &#34;vaccinations&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;vaccinations&#34;][-1][1] + vaccine_parameters[&#34;t_wait_vac&#34;] or \
                              &#34;infections&#34; in self.properties.keys() and \
                              timestamp &lt; self.properties[&#34;infections&#34;][-1][4] + vaccine_parameters[&#34;t_wait_rec&#34;]

        if not vaccine_unavailable:
            vaccination_data = [(timestamp,
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;],
                                 timestamp + vaccine_parameters[&#34;t_vac_effect&#34;] + vaccine_parameters[&#34;t_immunity&#34;])]

            if &#34;vaccinations&#34; in self.properties.keys():
                self.properties[&#34;vaccinations&#34;] += vaccination_data

            else:
                self.properties[&#34;vaccinations&#34;] = vaccination_data

            if self.immune:
                self._immune_in = 0
                self._susceptible_in = max(vaccine_parameters[&#34;t_immunity&#34;], self._susceptible_in)

            else:
                self._immune_in = vaccine_parameters[&#34;t_vac_effect&#34;]
                self._susceptible_in = vaccine_parameters[&#34;t_immunity&#34;]

            return True

        return False

    def test(self, timestamp: int):
        &#34;&#34;&#34;
        Test the member for an infection.

        Parameters
        ----------
        timestamp : int
            Current day in the simulation.

        Returns
        -------
        bool
            Whether the test is positive.
        &#34;&#34;&#34;

        result = self.infected * (np.random.uniform() &lt; 0.99)

        if &#34;tests&#34; not in self.properties.keys():
            self.properties[&#34;tests&#34;] = [0, 0]

        self.properties[&#34;tests&#34;][result] += 1
        self._last_tested = timestamp

        return result

    def quarantine(self, days: int):
        &#34;&#34;&#34;
        Place the member in quarantine.

        Parameters
        ----------
        days : int
            Amount of days (in the simulation) the member has to stay in
            quarantine.
        &#34;&#34;&#34;

        self.quarantined = True
        self._released_in = days

    def add_to_contacts(self, other: &#39;Member&#39;):
        &#34;&#34;&#34;
        Add &#39;other&#39; to the list of recent contacts of the member.

        Parameters
        ----------
        other : &#39;Member&#39;
            The member which is to be added to the list of recent contacts of
            the member on which &#39;add_to_contacts&#39; is called.
        &#34;&#34;&#34;

        if len(self.recent_contacts) &lt; 5:
            self.recent_contacts += [other]

        else:
            self.recent_contacts = self.recent_contacts[1:] + [other]

    def make_immune(self, immunity_duration: int):
        &#34;&#34;&#34;
        Make the member immune.
        Not to be used in the simulation other than in the initialization of
        groups (&#39;put_inits_in_respective_group&#39; in &#39;initialize_groups&#39; in
        &#39;start_iteration&#39;in the Simulation-class).

        Parameters
        ----------
        immunity_duration : int
            Amount of days (in the simulation) the member is to be immune.

        Returns
        -------
        bool
            Whether the member was infected before it has been made immune.
            This should never be the case.
        &#34;&#34;&#34;

        if self.infected: # This should never be the case.
            print(&#34;THIS SHOULD NOT APPEAR ON CONSOLE&#34;)
            self.infected = False
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return True

        else:
            self._infectious_in = -1
            self._recovers_in = -1
            self._susceptible_in = immunity_duration
            self.immune = True
            return False

    def make_dead(self, timestamp: int):
        &#34;&#34;&#34;
        Kill the member.

        Parameters
        ----------
        timestamp : int
            Current day in the simulation.
        &#34;&#34;&#34;

        self.infected = False
        self.recovered = False
        self.vaccinated = False
        self._susceptible_in = -1
        self._recovers_in = -1
        self._infectious_in = -1
        self._immune_in = -1

        self.dead = True
        self.properties[&#34;Death&#34;] = timestamp

    def make_tick(self, option: str, timestamp: int = None):
        &#34;&#34;&#34;
        Update the private counters of the member depending on the group or the
        stage the member is in.

        Parameters
        ----------
        option : str
            The type of update to be made.
            
        timestamp : int, optional
            Current day in the simulation.
            The default is None.

        Raises
        ------
        ValueError
            The &#39;option&#39;-string is expected to be one of the following strings:
            &#39;infectious&#39;,
            &#39;immunity&#39;,
            &#39;vaccine&#39;,
            &#39;recover&#39;,
            &#39;quarantine&#39;.
            If &#39;option&#39; does not meet the expectation,
            a ValueError will be raised.

        Returns
        -------
        bool
            Whether a change of attributes has been reached.
            No returns if option is &#39;vaccine&#39;.
        &#34;&#34;&#34;

        if option == &#34;infectious&#34;:
            if self._infectious_in &gt; 0:
                self._infectious_in -= 1

            return self._infectious_in &lt;= 0

        elif option == &#34;immunity&#34;:
            if self._immune_in &lt;= 0:
                self._susceptible_in -= 1
                if self._susceptible_in == 0:
                    self._susceptible_in = -1
                    self.immune = False
                    return True

            return False

        elif option == &#34;vaccine&#34;:
            self._immune_in -= 1
            if self._immune_in == 0:
                self.immune = True

        elif option == &#34;recover&#34;:
            self._recovers_in -= 1
            if self._recovers_in == 0:
                self._recovers_in = -1
                self.infected = False
                self.immune = True
                return True

            return False

        elif option == &#34;quarantine&#34;:
            self._released_in -= 1

            if &#34;days_in_quarantine&#34; not in self.properties.keys():
                self.properties[&#34;days_in_quarantine&#34;] = 0

            self.properties[&#34;days_in_quarantine&#34;] += 1

            if self._released_in == 0:
                if self.test(timestamp):
                    self._released_in += 5
                else:
                    self._released_in = -1
                    self.quarantined = False
                    return True

            return False

        else:
            raise ValueError(&#34;option not supported&#34;)

    def copy(self):
        &#34;&#34;&#34;
        Create a member as a copy of the member.
        (Deep copy)

        Returns
        -------
        Member
            The copy of the member.
        &#34;&#34;&#34;

        m = Member(self.properties.copy())
        m.infected = self.infected
        m.recovered = self.recovered
        m.vaccinated = self.vaccinated
        m.dead = self.dead
        m._susceptible_in = self._susceptible_in
        m._recovers_in = self._recovers_in
        m._infectious_in = self._infectious_in
        m._immune_in = self._immune_in

        return m</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.Network.Member.add_to_contacts"><code class="name flex">
<span>def <span class="ident">add_to_contacts</span></span>(<span>self, other: <a title="src.Network.Member" href="#src.Network.Member">Member</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add 'other' to the list of recent contacts of the member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>'Member'</code></dt>
<dd>The member which is to be added to the list of recent contacts of
the member on which 'add_to_contacts' is called.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_contacts(self, other: &#39;Member&#39;):
    &#34;&#34;&#34;
    Add &#39;other&#39; to the list of recent contacts of the member.

    Parameters
    ----------
    other : &#39;Member&#39;
        The member which is to be added to the list of recent contacts of
        the member on which &#39;add_to_contacts&#39; is called.
    &#34;&#34;&#34;

    if len(self.recent_contacts) &lt; 5:
        self.recent_contacts += [other]

    else:
        self.recent_contacts = self.recent_contacts[1:] + [other]</code></pre>
</details>
</dd>
<dt id="src.Network.Member.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a member as a copy of the member.
(Deep copy)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.Network.Member" href="#src.Network.Member">Member</a></code></dt>
<dd>The copy of the member.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Create a member as a copy of the member.
    (Deep copy)

    Returns
    -------
    Member
        The copy of the member.
    &#34;&#34;&#34;

    m = Member(self.properties.copy())
    m.infected = self.infected
    m.recovered = self.recovered
    m.vaccinated = self.vaccinated
    m.dead = self.dead
    m._susceptible_in = self._susceptible_in
    m._recovers_in = self._recovers_in
    m._infectious_in = self._infectious_in
    m._immune_in = self._immune_in

    return m</code></pre>
</details>
</dd>
<dt id="src.Network.Member.infect"><code class="name flex">
<span>def <span class="ident">infect</span></span>(<span>self, infectant: <a title="src.Network.Member" href="#src.Network.Member">Member</a>, timestamp: int, disease_parameters: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Infect the member, if it is infectable.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>infectant</code></strong> :&ensp;<code>'Member'</code></dt>
<dd>The infectious member that infects the member on which 'infect' is
applied.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code></dt>
<dd>Current day in the simulation.</dd>
<dt><strong><code>disease_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all relevant infection parameters.
Is expected to contain the keys
'incubation_period',
'infection_period',
'vaccine_failure_probability_heuristic',
'immunity_period'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the member has been infected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infect(self, infectant: &#39;Member&#39;, timestamp: int, disease_parameters: dict):
    &#34;&#34;&#34;
    Infect the member, if it is infectable.

    Parameters
    ----------
    infectant : &#39;Member&#39;
        The infectious member that infects the member on which &#39;infect&#39; is
        applied.

    timestamp : int
        Current day in the simulation.

    disease_parameters : dict
        Dictionary containing all relevant infection parameters.
        Is expected to contain the keys
        &#39;incubation_period&#39;,
        &#39;infection_period&#39;,
        &#39;vaccine_failure_probability_heuristic&#39;,
        &#39;immunity_period&#39;.

    Returns
    -------
    bool
        Whether the member has been infected.
    &#34;&#34;&#34;

    n_incubation = disease_parameters[&#34;incubation_period&#34;]
    n_infection = disease_parameters[&#34;infection_period&#34;]
    shared_household = self.properties[&#34;household&#34;] == infectant.properties[&#34;household&#34;]

    if (self.immune and not self.vaccinated) or self.infected or \
            self.dead or (self.quarantined and not shared_household):
        return False

    if self.vaccinated and self._immune_in &lt;= 0:
        p_failure = disease_parameters[&#34;vaccine_failure_probability_heuristic&#34;](self, timestamp)
        if np.random.uniform() &gt; p_failure:
            return False

    infection_data = [(infectant.properties[&#34;id&#34;],
                       shared_household,
                       timestamp,
                       timestamp + n_incubation,
                       timestamp + n_incubation + n_infection)]

    if &#34;infections&#34; not in self.properties.keys():
        self.properties[&#34;infections&#34;] = infection_data

    else:
        self.properties[&#34;infections&#34;] += infection_data

    self.infected = True
    self._infectious_in = n_incubation
    self._recovers_in = n_infection
    self._susceptible_in = disease_parameters[&#34;immunity_period&#34;]

    return True</code></pre>
</details>
</dd>
<dt id="src.Network.Member.make_dead"><code class="name flex">
<span>def <span class="ident">make_dead</span></span>(<span>self, timestamp: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Kill the member.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code></dt>
<dd>Current day in the simulation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_dead(self, timestamp: int):
    &#34;&#34;&#34;
    Kill the member.

    Parameters
    ----------
    timestamp : int
        Current day in the simulation.
    &#34;&#34;&#34;

    self.infected = False
    self.recovered = False
    self.vaccinated = False
    self._susceptible_in = -1
    self._recovers_in = -1
    self._infectious_in = -1
    self._immune_in = -1

    self.dead = True
    self.properties[&#34;Death&#34;] = timestamp</code></pre>
</details>
</dd>
<dt id="src.Network.Member.make_immune"><code class="name flex">
<span>def <span class="ident">make_immune</span></span>(<span>self, immunity_duration: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the member immune.
Not to be used in the simulation other than in the initialization of
groups ('put_inits_in_respective_group' in 'initialize_groups' in
'start_iteration'in the Simulation-class).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>immunity_duration</code></strong> :&ensp;<code>int</code></dt>
<dd>Amount of days (in the simulation) the member is to be immune.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the member was infected before it has been made immune.
This should never be the case.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_immune(self, immunity_duration: int):
    &#34;&#34;&#34;
    Make the member immune.
    Not to be used in the simulation other than in the initialization of
    groups (&#39;put_inits_in_respective_group&#39; in &#39;initialize_groups&#39; in
    &#39;start_iteration&#39;in the Simulation-class).

    Parameters
    ----------
    immunity_duration : int
        Amount of days (in the simulation) the member is to be immune.

    Returns
    -------
    bool
        Whether the member was infected before it has been made immune.
        This should never be the case.
    &#34;&#34;&#34;

    if self.infected: # This should never be the case.
        print(&#34;THIS SHOULD NOT APPEAR ON CONSOLE&#34;)
        self.infected = False
        self._infectious_in = -1
        self._recovers_in = -1
        self._susceptible_in = immunity_duration
        self.immune = True
        return True

    else:
        self._infectious_in = -1
        self._recovers_in = -1
        self._susceptible_in = immunity_duration
        self.immune = True
        return False</code></pre>
</details>
</dd>
<dt id="src.Network.Member.make_tick"><code class="name flex">
<span>def <span class="ident">make_tick</span></span>(<span>self, option: str, timestamp: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the private counters of the member depending on the group or the
stage the member is in.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>option</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of update to be made.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Current day in the simulation.
The default is None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>The 'option'-string is expected to be one of the following strings:
'infectious',
'immunity',
'vaccine',
'recover',
'quarantine'.
If 'option' does not meet the expectation,
a ValueError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether a change of attributes has been reached.
No returns if option is 'vaccine'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_tick(self, option: str, timestamp: int = None):
    &#34;&#34;&#34;
    Update the private counters of the member depending on the group or the
    stage the member is in.

    Parameters
    ----------
    option : str
        The type of update to be made.
        
    timestamp : int, optional
        Current day in the simulation.
        The default is None.

    Raises
    ------
    ValueError
        The &#39;option&#39;-string is expected to be one of the following strings:
        &#39;infectious&#39;,
        &#39;immunity&#39;,
        &#39;vaccine&#39;,
        &#39;recover&#39;,
        &#39;quarantine&#39;.
        If &#39;option&#39; does not meet the expectation,
        a ValueError will be raised.

    Returns
    -------
    bool
        Whether a change of attributes has been reached.
        No returns if option is &#39;vaccine&#39;.
    &#34;&#34;&#34;

    if option == &#34;infectious&#34;:
        if self._infectious_in &gt; 0:
            self._infectious_in -= 1

        return self._infectious_in &lt;= 0

    elif option == &#34;immunity&#34;:
        if self._immune_in &lt;= 0:
            self._susceptible_in -= 1
            if self._susceptible_in == 0:
                self._susceptible_in = -1
                self.immune = False
                return True

        return False

    elif option == &#34;vaccine&#34;:
        self._immune_in -= 1
        if self._immune_in == 0:
            self.immune = True

    elif option == &#34;recover&#34;:
        self._recovers_in -= 1
        if self._recovers_in == 0:
            self._recovers_in = -1
            self.infected = False
            self.immune = True
            return True

        return False

    elif option == &#34;quarantine&#34;:
        self._released_in -= 1

        if &#34;days_in_quarantine&#34; not in self.properties.keys():
            self.properties[&#34;days_in_quarantine&#34;] = 0

        self.properties[&#34;days_in_quarantine&#34;] += 1

        if self._released_in == 0:
            if self.test(timestamp):
                self._released_in += 5
            else:
                self._released_in = -1
                self.quarantined = False
                return True

        return False

    else:
        raise ValueError(&#34;option not supported&#34;)</code></pre>
</details>
</dd>
<dt id="src.Network.Member.quarantine"><code class="name flex">
<span>def <span class="ident">quarantine</span></span>(<span>self, days: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Place the member in quarantine.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>days</code></strong> :&ensp;<code>int</code></dt>
<dd>Amount of days (in the simulation) the member has to stay in
quarantine.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quarantine(self, days: int):
    &#34;&#34;&#34;
    Place the member in quarantine.

    Parameters
    ----------
    days : int
        Amount of days (in the simulation) the member has to stay in
        quarantine.
    &#34;&#34;&#34;

    self.quarantined = True
    self._released_in = days</code></pre>
</details>
</dd>
<dt id="src.Network.Member.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>self, timestamp: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Test the member for an infection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code></dt>
<dd>Current day in the simulation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the test is positive.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test(self, timestamp: int):
    &#34;&#34;&#34;
    Test the member for an infection.

    Parameters
    ----------
    timestamp : int
        Current day in the simulation.

    Returns
    -------
    bool
        Whether the test is positive.
    &#34;&#34;&#34;

    result = self.infected * (np.random.uniform() &lt; 0.99)

    if &#34;tests&#34; not in self.properties.keys():
        self.properties[&#34;tests&#34;] = [0, 0]

    self.properties[&#34;tests&#34;][result] += 1
    self._last_tested = timestamp

    return result</code></pre>
</details>
</dd>
<dt id="src.Network.Member.vaccinate"><code class="name flex">
<span>def <span class="ident">vaccinate</span></span>(<span>self, timestamp: int, vaccine_parameters: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Vaccinate the member, if it is allowed to be vaccinated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code></dt>
<dd>Current day in the simulation.</dd>
<dt><strong><code>vaccine_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary containing all relevant vaccination parameters.
Is expected to contain the keys
't_wait_vac',
't_wait_rec',
't_vac_effect',
't_immunity'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the member has been vaccinated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vaccinate(self, timestamp: int, vaccine_parameters: dict):
    &#34;&#34;&#34;
    Vaccinate the member, if it is allowed to be vaccinated.

    Parameters
    ----------
    timestamp : int
        Current day in the simulation.

    vaccine_parameters : dict
        Dictionary containing all relevant vaccination parameters.
        Is expected to contain the keys
        &#39;t_wait_vac&#39;,
        &#39;t_wait_rec&#39;,
        &#39;t_vac_effect&#39;,
        &#39;t_immunity&#39;.

    Returns
    -------
    bool
        Whether the member has been vaccinated.
    &#34;&#34;&#34;

    vaccine_unavailable = self.infected or self.dead or self.quarantined or \
                          &#34;vaccinations&#34; in self.properties.keys() and \
                          timestamp &lt; self.properties[&#34;vaccinations&#34;][-1][1] + vaccine_parameters[&#34;t_wait_vac&#34;] or \
                          &#34;infections&#34; in self.properties.keys() and \
                          timestamp &lt; self.properties[&#34;infections&#34;][-1][4] + vaccine_parameters[&#34;t_wait_rec&#34;]

    if not vaccine_unavailable:
        vaccination_data = [(timestamp,
                             timestamp + vaccine_parameters[&#34;t_vac_effect&#34;],
                             timestamp + vaccine_parameters[&#34;t_vac_effect&#34;] + vaccine_parameters[&#34;t_immunity&#34;])]

        if &#34;vaccinations&#34; in self.properties.keys():
            self.properties[&#34;vaccinations&#34;] += vaccination_data

        else:
            self.properties[&#34;vaccinations&#34;] = vaccination_data

        if self.immune:
            self._immune_in = 0
            self._susceptible_in = max(vaccine_parameters[&#34;t_immunity&#34;], self._susceptible_in)

        else:
            self._immune_in = vaccine_parameters[&#34;t_vac_effect&#34;]
            self._susceptible_in = vaccine_parameters[&#34;t_immunity&#34;]

        return True

    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.Network.Population"><code class="flex name class">
<span>class <span class="ident">Population</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of a larger set of people from several households.
A subclass of Group, additionally consisting of a list of households.</p>
<p>Create a new population named 'name'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the new population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Population(Group):
    def __init__(self, name: str):
        &#34;&#34;&#34;
        A representation of a larger set of people from several households.
        A subclass of Group, additionally consisting of a list of households.
        
        Create a new population named &#39;name&#39;.

        Parameters
        ----------
        name : str
            The name of the new population.
        &#34;&#34;&#34;

        super().__init__(name)
        self.households = {}

    def add_member(self, member: &#39;Member&#39;):
        &#34;&#34;&#34;
        Add &#39;member&#39; as a Member to the Population
        and to its Household within the Population.

        Parameters
        ----------
        member : Member
            The member to be added to the Population.

        Raises
        ------
        KeyError
            The member &#39;member&#39; is expected to have the property &#39;household&#39;.
            If &#39;member&#39; does not meet the expectations,
            a KeyError will be raised.
        &#34;&#34;&#34;

        household_id = member.properties[&#34;household&#34;]
        if household_id in self.households.keys():
            self.households[household_id].add_member(member)
        else:
            household = Household(household_id)
            self.households[household_id] = household
            self.households[household_id].add_member(member)

        if type(self.members) == np.ndarray:
            self.members = np.append(self.members, member)
        else:
            self.members += [member]

        self.counter.increment()

    def save_as_json(self, path: str):
        &#34;&#34;&#34;
        Save the population as population.json at the given &#39;path&#39;.

        Parameters
        ----------
        path : str
            The path at which the population-file is to be saved.

        Raises
        ------
        ValueError
            The population is expected to contain members.
            If the population does not meet the expectation,
            a ValueError will be raised.
        &#34;&#34;&#34;

        if len(self.members) == 0:
            raise ValueError(&#34;Population can&#39;t be empty.&#34;)

        with open(path + &#34;population.json&#34;, &#39;w&#39;) as f:
            wrapper = &#34;{\n\t\&#34;name\&#34;: \&#34;&#34; + self.name + &#34;\&#34;,\n\t\&#34;size\&#34;: &#34; + str(self.size) + &#34;,\n\t\&#34;members\&#34;: [\n&#34;
            inner = &#34;&#34;
            for member in self:
                json_str = json.dumps(member.properties, indent=4)
                inner += json_str + &#39;, \n&#39;

            inner = textwrap.indent(inner[:-3] + &#39;\n&#39;, &#39;\t\t&#39;)

            f.write(wrapper + inner + &#34;\t]\n}&#34;)
            f.close()

    def copy(self):
        &#34;&#34;&#34;
        Create a population as a copy of the population.
        (deep copy)

        Returns
        -------
        Population
            The copy of the population.
        &#34;&#34;&#34;

        p = Population(self.name)
        p.members = list(p.members)
        for member in self.members:
            p.add_member(member.copy())

        p.members = np.array(p.members)
        p.counter = self.counter.copy()

        return p

    @staticmethod
    def load_from_csv(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv.

        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-4])
        p.members = []
        with open(path + file_name, newline=&#39;&#39;) as f:
            progress = ProgressBar(1, sum(1 for _ in f) - 1)

        print(&#34;Loading population data...&#34;)

        progress.update(0)
        with open(path + file_name, newline=&#39;&#39;) as f:
            for m_dict in csv.DictReader(f):
                progress.update(1)
                p.add_member(Member(m_dict))

        print(&#34;\nFinished loading.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_json(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .json.

        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        p = Population(file_name[:-5])
        p.members = []
        with open(path + file_name, &#34;r&#34;) as f:
            print(&#34;Load json...&#34;)
            data = json.load(f)
            print(&#34;Finished loading.\n\nAdding members to population...&#34;)

            progress = ProgressBar(1, len(data[&#34;members&#34;]))
            progress.update(0)
            for member in data[&#34;members&#34;]:
                progress.update(1)
                p.add_member(Member(member))

            print(&#34;\nFinished adding members.&#34;)

        p.members = np.array(p.members)
        p.counter.squash_history()
        return p

    @staticmethod
    def load_from_file(file_name: str, path: str = &#34;Populations&#34; + sep):
        &#34;&#34;&#34;
        Create a Population object according to the data given in file_name.

        Parameters
        ----------
        file_name : str
            The name of the file containing the data of the population.
            Expected to end in .csv or .json.

        path : str, optional
            The path to the file named file_name.
            The default is &#34;Populations&#34; + sep.

        Raises
        ------
        ValueError
            file_name is expected to end in .csv or .json.
            If file_name does not meet the expectation,
            a ValueError will be raised.

        Returns
        -------
        Population
            A Population object containing the data for the given file.
        &#34;&#34;&#34;

        if file_name[-4:] == &#34;.csv&#34;:
            return Population.load_from_csv(file_name, path)
        elif file_name[-5:] == &#34;.json&#34;:
            return Population.load_from_json(file_name, path)
        else:
            raise ValueError(&#34;file_name must end in .csv or .json.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.Network.Group" href="#src.Network.Group">Group</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="src.Network.Population.load_from_csv"><code class="name flex">
<span>def <span class="ident">load_from_csv</span></span>(<span>file_name: str, path: str = 'Populations/')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Population object according to the data given in file_name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file containing the data of the population.
Expected to end in .csv.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file named file_name.
The default is "Populations" + sep.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></dt>
<dd>A Population object containing the data for the given file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_csv(file_name: str, path: str = &#34;Populations&#34; + sep):
    &#34;&#34;&#34;
    Create a Population object according to the data given in file_name.

    Parameters
    ----------
    file_name : str
        The name of the file containing the data of the population.
        Expected to end in .csv.

    path : str, optional
        The path to the file named file_name.
        The default is &#34;Populations&#34; + sep.

    Returns
    -------
    Population
        A Population object containing the data for the given file.
    &#34;&#34;&#34;

    p = Population(file_name[:-4])
    p.members = []
    with open(path + file_name, newline=&#39;&#39;) as f:
        progress = ProgressBar(1, sum(1 for _ in f) - 1)

    print(&#34;Loading population data...&#34;)

    progress.update(0)
    with open(path + file_name, newline=&#39;&#39;) as f:
        for m_dict in csv.DictReader(f):
            progress.update(1)
            p.add_member(Member(m_dict))

    print(&#34;\nFinished loading.&#34;)

    p.members = np.array(p.members)
    p.counter.squash_history()
    return p</code></pre>
</details>
</dd>
<dt id="src.Network.Population.load_from_file"><code class="name flex">
<span>def <span class="ident">load_from_file</span></span>(<span>file_name: str, path: str = 'Populations/')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Population object according to the data given in file_name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file containing the data of the population.
Expected to end in .csv or .json.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file named file_name.
The default is "Populations" + sep.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>file_name is expected to end in .csv or .json.
If file_name does not meet the expectation,
a ValueError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></dt>
<dd>A Population object containing the data for the given file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_file(file_name: str, path: str = &#34;Populations&#34; + sep):
    &#34;&#34;&#34;
    Create a Population object according to the data given in file_name.

    Parameters
    ----------
    file_name : str
        The name of the file containing the data of the population.
        Expected to end in .csv or .json.

    path : str, optional
        The path to the file named file_name.
        The default is &#34;Populations&#34; + sep.

    Raises
    ------
    ValueError
        file_name is expected to end in .csv or .json.
        If file_name does not meet the expectation,
        a ValueError will be raised.

    Returns
    -------
    Population
        A Population object containing the data for the given file.
    &#34;&#34;&#34;

    if file_name[-4:] == &#34;.csv&#34;:
        return Population.load_from_csv(file_name, path)
    elif file_name[-5:] == &#34;.json&#34;:
        return Population.load_from_json(file_name, path)
    else:
        raise ValueError(&#34;file_name must end in .csv or .json.&#34;)</code></pre>
</details>
</dd>
<dt id="src.Network.Population.load_from_json"><code class="name flex">
<span>def <span class="ident">load_from_json</span></span>(<span>file_name: str, path: str = 'Populations/')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Population object according to the data given in file_name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file containing the data of the population.
Expected to end in .json.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file named file_name.
The default is "Populations" + sep.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></dt>
<dd>A Population object containing the data for the given file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_json(file_name: str, path: str = &#34;Populations&#34; + sep):
    &#34;&#34;&#34;
    Create a Population object according to the data given in file_name.

    Parameters
    ----------
    file_name : str
        The name of the file containing the data of the population.
        Expected to end in .json.

    path : str, optional
        The path to the file named file_name.
        The default is &#34;Populations&#34; + sep.

    Returns
    -------
    Population
        A Population object containing the data for the given file.
    &#34;&#34;&#34;

    p = Population(file_name[:-5])
    p.members = []
    with open(path + file_name, &#34;r&#34;) as f:
        print(&#34;Load json...&#34;)
        data = json.load(f)
        print(&#34;Finished loading.\n\nAdding members to population...&#34;)

        progress = ProgressBar(1, len(data[&#34;members&#34;]))
        progress.update(0)
        for member in data[&#34;members&#34;]:
            progress.update(1)
            p.add_member(Member(member))

        print(&#34;\nFinished adding members.&#34;)

    p.members = np.array(p.members)
    p.counter.squash_history()
    return p</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.Network.Population.add_member"><code class="name flex">
<span>def <span class="ident">add_member</span></span>(<span>self, member: <a title="src.Network.Member" href="#src.Network.Member">Member</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add 'member' as a Member to the Population
and to its Household within the Population.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>member</code></strong> :&ensp;<code><a title="src.Network.Member" href="#src.Network.Member">Member</a></code></dt>
<dd>The member to be added to the Population.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>The member 'member' is expected to have the property 'household'.
If 'member' does not meet the expectations,
a KeyError will be raised.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_member(self, member: &#39;Member&#39;):
    &#34;&#34;&#34;
    Add &#39;member&#39; as a Member to the Population
    and to its Household within the Population.

    Parameters
    ----------
    member : Member
        The member to be added to the Population.

    Raises
    ------
    KeyError
        The member &#39;member&#39; is expected to have the property &#39;household&#39;.
        If &#39;member&#39; does not meet the expectations,
        a KeyError will be raised.
    &#34;&#34;&#34;

    household_id = member.properties[&#34;household&#34;]
    if household_id in self.households.keys():
        self.households[household_id].add_member(member)
    else:
        household = Household(household_id)
        self.households[household_id] = household
        self.households[household_id].add_member(member)

    if type(self.members) == np.ndarray:
        self.members = np.append(self.members, member)
    else:
        self.members += [member]

    self.counter.increment()</code></pre>
</details>
</dd>
<dt id="src.Network.Population.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a population as a copy of the population.
(deep copy)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></dt>
<dd>The copy of the population.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Create a population as a copy of the population.
    (deep copy)

    Returns
    -------
    Population
        The copy of the population.
    &#34;&#34;&#34;

    p = Population(self.name)
    p.members = list(p.members)
    for member in self.members:
        p.add_member(member.copy())

    p.members = np.array(p.members)
    p.counter = self.counter.copy()

    return p</code></pre>
</details>
</dd>
<dt id="src.Network.Population.save_as_json"><code class="name flex">
<span>def <span class="ident">save_as_json</span></span>(<span>self, path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the population as population.json at the given 'path'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path at which the population-file is to be saved.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>The population is expected to contain members.
If the population does not meet the expectation,
a ValueError will be raised.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as_json(self, path: str):
    &#34;&#34;&#34;
    Save the population as population.json at the given &#39;path&#39;.

    Parameters
    ----------
    path : str
        The path at which the population-file is to be saved.

    Raises
    ------
    ValueError
        The population is expected to contain members.
        If the population does not meet the expectation,
        a ValueError will be raised.
    &#34;&#34;&#34;

    if len(self.members) == 0:
        raise ValueError(&#34;Population can&#39;t be empty.&#34;)

    with open(path + &#34;population.json&#34;, &#39;w&#39;) as f:
        wrapper = &#34;{\n\t\&#34;name\&#34;: \&#34;&#34; + self.name + &#34;\&#34;,\n\t\&#34;size\&#34;: &#34; + str(self.size) + &#34;,\n\t\&#34;members\&#34;: [\n&#34;
        inner = &#34;&#34;
        for member in self:
            json_str = json.dumps(member.properties, indent=4)
            inner += json_str + &#39;, \n&#39;

        inner = textwrap.indent(inner[:-3] + &#39;\n&#39;, &#39;\t\t&#39;)

        f.write(wrapper + inner + &#34;\t]\n}&#34;)
        f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.Network.Group" href="#src.Network.Group">Group</a></b></code>:
<ul class="hlist">
<li><code><a title="src.Network.Group.move" href="#src.Network.Group.move">move</a></code></li>
<li><code><a title="src.Network.Group.remove_member" href="#src.Network.Group.remove_member">remove_member</a></code></li>
<li><code><a title="src.Network.Group.reset" href="#src.Network.Group.reset">reset</a></code></li>
<li><code><a title="src.Network.Group.spread_disease" href="#src.Network.Group.spread_disease">spread_disease</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Network.Group" href="#src.Network.Group">Group</a></code></h4>
<ul class="two-column">
<li><code><a title="src.Network.Group.add_member" href="#src.Network.Group.add_member">add_member</a></code></li>
<li><code><a title="src.Network.Group.history" href="#src.Network.Group.history">history</a></code></li>
<li><code><a title="src.Network.Group.move" href="#src.Network.Group.move">move</a></code></li>
<li><code><a title="src.Network.Group.remove_member" href="#src.Network.Group.remove_member">remove_member</a></code></li>
<li><code><a title="src.Network.Group.reset" href="#src.Network.Group.reset">reset</a></code></li>
<li><code><a title="src.Network.Group.size" href="#src.Network.Group.size">size</a></code></li>
<li><code><a title="src.Network.Group.spread_disease" href="#src.Network.Group.spread_disease">spread_disease</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Network.Household" href="#src.Network.Household">Household</a></code></h4>
<ul class="">
<li><code><a title="src.Network.Household.id" href="#src.Network.Household.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Network.Member" href="#src.Network.Member">Member</a></code></h4>
<ul class="two-column">
<li><code><a title="src.Network.Member.add_to_contacts" href="#src.Network.Member.add_to_contacts">add_to_contacts</a></code></li>
<li><code><a title="src.Network.Member.copy" href="#src.Network.Member.copy">copy</a></code></li>
<li><code><a title="src.Network.Member.infect" href="#src.Network.Member.infect">infect</a></code></li>
<li><code><a title="src.Network.Member.make_dead" href="#src.Network.Member.make_dead">make_dead</a></code></li>
<li><code><a title="src.Network.Member.make_immune" href="#src.Network.Member.make_immune">make_immune</a></code></li>
<li><code><a title="src.Network.Member.make_tick" href="#src.Network.Member.make_tick">make_tick</a></code></li>
<li><code><a title="src.Network.Member.quarantine" href="#src.Network.Member.quarantine">quarantine</a></code></li>
<li><code><a title="src.Network.Member.test" href="#src.Network.Member.test">test</a></code></li>
<li><code><a title="src.Network.Member.vaccinate" href="#src.Network.Member.vaccinate">vaccinate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Network.Population" href="#src.Network.Population">Population</a></code></h4>
<ul class="two-column">
<li><code><a title="src.Network.Population.add_member" href="#src.Network.Population.add_member">add_member</a></code></li>
<li><code><a title="src.Network.Population.copy" href="#src.Network.Population.copy">copy</a></code></li>
<li><code><a title="src.Network.Population.load_from_csv" href="#src.Network.Population.load_from_csv">load_from_csv</a></code></li>
<li><code><a title="src.Network.Population.load_from_file" href="#src.Network.Population.load_from_file">load_from_file</a></code></li>
<li><code><a title="src.Network.Population.load_from_json" href="#src.Network.Population.load_from_json">load_from_json</a></code></li>
<li><code><a title="src.Network.Population.save_as_json" href="#src.Network.Population.save_as_json">save_as_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>